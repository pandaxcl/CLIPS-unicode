;;; vim:expandtab autoindent
(defmethod repeat ((?text LEXEME) (?count INTEGER))
    (bind ?result "")
    (loop-for-count ?count
        (bind ?result (str-cat ?text ?result))
    )
    (return ?result)
)
(defmethod   indent   (     ) "    ")
(defmethod   indent   (?n   ) (repeat (indent) ?n))
(defmethod   space    (     ) " ")
(defmethod   space    (?n   ) (repeat (space) ?n))
(defmethod   quote    (     ) "\"")
(defmethod   quote    (?text) (str-cat (quote) ?text (quote)))
(deffunction newline  (     ) (format nil "%n"))
(deffunction identity (?text) ?text)

(defmethod join$ (?M ($?S LEXEME))
    (bind ?text "")
    (progn$ (?v ?M) 
            (bind ?sep (if (<> ?v-index (length$ ?M)) 
                then (str-cat (expand$ ?S))
                else ""
            ))
            (bind ?text (str-cat ?text ?v ?sep))
    )
    (return ?text)
)
(defmethod join$ (?M) (join$ ?M " "))

(deffunction join-with-default$ (?M ?S ?default)
    (if (> (length$ ?M) 0) 
        then (return (join$ ?M ?S))
    )
    (return ?default)
)
(deffunction     empty$ (?M) (=   (length$ ?M) 0))
(deffunction not-empty$ (?M) (not ( empty$ ?M)  ))

(deffunction has-only-one$ (?M) (=    1 (length$ ?M)))
(deffunction the-only-one$ (?M) (nth$ 1          ?M))

(deffunction append$ (?M $?x)
    (if (> (length$ ?x) 0)
        then (return (insert$ ?M (+ (length$ ?M) 1) ?x))
    )
    (return ?M)
)
(deffunction append-cat$ (?M $?x)
    (append$ ?M (str-cat (expand$ ?x)))
)
(deffunction slot-append$ (?instance ?slot $?x)
   ;(if (empty$ ?x) then (return FALSE))
    (bind ?i 1)
    (if (multifieldp (send ?instance (sym-cat get- ?slot))) then
        (bind ?values (send ?instance (sym-cat get- ?slot)))
        (bind ?i (+ 1 (length$ ?values)))
    )
    (slot-insert$ ?instance ?slot ?i ?x)
   ;(slot-insert$ ?instance ?slot ?i (expand$ ?x))
)
(deffunction append-if-not-exist$ (?M $?x)
    (bind ?R ?M)
    (progn$ (?v ?x)
            (if (not (member$ ?v ?M)) 
                then (bind ?R (append$ ?R ?v)))
    )
    (return ?R)
)

(defmethod indent$ ((?n INTEGER) (?M MULTIFIELD))
    (bind ?X (create$))
    (progn$ (?v ?M) (bind ?X (append$ ?X (str-cat (indent ?n) ?v))))
    (return ?X)
)

(defmethod repeat$ (?text (?count INTEGER))
    (bind ?result (create$))
    (loop-for-count ?count
        (bind ?result (append$ ?result ?text))
    )
    (return ?result)
)

(defmethod filter ((?M MULTIFIELD) (?expr STRING))
    (eval (str-cat 
        "(progn"
            "(bind ?X (create$))"
            "(bind ?M (create$ "(implode$ ?M)"))"
            "(progn$ (?v ?M) (if (eval "?expr") then (bind ?X (append$ ?X ?v))))"
            "?X"
        ")"
    ))
)
(defmethod map ((?M MULTIFIELD) (?expr STRING))
    (eval (str-cat 
        "(progn"
            "(bind ?X (create$))"
            "(bind ?M (create$ "(implode$ ?M)"))"
            "(progn$ (?v ?M) (bind ?X (append$ ?X " ?expr ")))"
            "?X"
        ")"
    ))
)

;;; (get-current-module)只能以参数的形式传入，在该函数中直接调用(get-current-module)，结果不正确！
(deffunction make-module (?current-module ?child-module $?module-path)
    (bind ?module (str-cat ?current-module ":" ?child-module))
    (bind ?import (str-cat "(import "?current-module" ?ALL)"))
    (build (str-cat "(defmodule "?module" "?import")"))
    (progn$ (?v ?module-path) (load ?v))
    (set-current-module ?current-module)
)

(deffunction str-equal (?lhs ?rhs)
    (= 0 (str-compare (str-cat ?lhs) (str-cat ?rhs)))
)
(deffunction str-not-equal (?lhs ?rhs)
    (!= 0 (str-compare (str-cat ?lhs) (str-cat ?rhs)))
)
(deffunction str-starts-with (?with ?string)
    (bind ?end (str-length ?with))
    (str-equal (sub-string 1 ?end ?string) ?with)
)
(deffunction str-ends-with (?with ?string)
    (bind ?begin (+ 1 (- (str-length ?string)
                         (str-length ?with))))
    (bind ?end   (str-length ?string))
    (str-equal (sub-string ?begin ?end ?string) ?with)
)
(deffunction str-make-first-upper (?string)
    (bind ?n (str-length ?string))
    (if (> ?n 0) then
        (bind ?first (sub-string 1  1 ?string))
        (bind ?rest  (sub-string 2 ?n ?string))
        (return (str-cat (upcase ?first) ?rest))
    )
    (return ?string)
)

(defmethod expr-normalized ((?expr LEXEME))
    (implode$ (explode$ ?expr))
)
(defmethod expr-equal ((?A LEXEME)(?B LEXEME))
    (str-equal (expr-normalized ?A)(expr-normalized ?B))
)
(defmethod is-kind-of   ((?class SYMBOL) ?object) (superclassp ?class (class ?object)))
(defmethod is-member-of ((?class SYMBOL) ?object) (eq          ?class (class ?object)))

(defmethod Q (      ) (quote      ))
(defmethod Q ( ?text) (quote ?text))
(defmethod Q ($?text) (quote (join$ ?text "")))
(defmethod S (  ) (space  1))
(defmethod S (?n) (space ?n))
(defmethod I (  ) (space  0))
(defmethod I (?s) (identity ?s))

(deffunction L () "(")
(deffunction R () ")")
(deffunction N () (newline))

(deffunction halt-with-error ($?err)
    (println [HALT-WITH-ERROR]: ?err)
    (halt)
)
(deffunction halt-method-with-arguments (?TAG ?USER $?arguments)
    (println (repeat = 60))
    (println [ERROR(L)FATAL(R)(L)?TAG(R)]: tab "halt method with arguments:" tab ?arguments)
    (send ?USER print)
    (println (repeat ^ 60))
    (halt)
)

(deffunction key-argument-p (?argument) 
    (and (symbolp         ?argument)
         (str-ends-with : ?argument)
    )
)

;;; 注解基类
(defclass Annotation (is-a USER)
    (slot annotation (type INSTANCE)(allowed-classes USER))
)
;;; Dictionary
(defclass Dictionary (is-a USER)(pattern-match non-reactive)
    (slot dictionary (type INSTANCE)(allowed-classes USER))
)
(defmessage-handler Dictionary init after () (bind ?self:dictionary ?self))
(defgeneric #DictionaryParse)
(deffunction Dictionary ($?arguments) (#DictionaryParse (expand$ ?arguments)))
(defmethod  #DictionaryParse ((?self USER)                                         $?X) (halt-method-with-arguments #DictionaryParse ?self (expand$ ?X)))
(defmethod  #DictionaryParse ((?class SYMBOL (class-existp ?class))                $?X) (#DictionaryParse (make-instance of ?class) (expand$ ?X)))
(defmethod  #DictionaryParse ((?self Dictionary)(?k SYMBOL (key-argument-p ?k)) ?v $?X) (#DictionaryParse ?self (expand$ ?X)))

;;; 将多字段值用instance对象表示，使得defmethod的写法和但字段类型一致
(defclass Multifield (is-a USER)(pattern-match non-reactive)
    (multislot multifield)
)
(deffunction Multifield ($?arguments) 
    (make-instance of Multifield (multifield ?arguments))
)


(deffunction make-packed-arguments ($?arguments)
    (bind ?packed       (create$))
    (bind ?multifield   (create$))
    (bind ?key-argument-exist FALSE)
    (progn$ (?current ?arguments)
        (bind ?multifield (append$ ?multifield ?current))
        (if (key-argument-p ?current) then 
            (bind ?key-argument-exist (or ?key-argument-exist TRUE))
           ;(println "1 ?multifield: " ?multifield " ?packed: " ?packed)
            (if (key-argument-p (nth$ 1 ?multifield)) 
                then (if (> (length$ ?multifield) 3)
                         then (bind ?packed (append$ ?packed (first$ ?multifield)))
                              (bind ?packed (append$ ?packed (Multifield (subseq$ ?multifield 2 (- (length$ ?multifield) 1)))))
                         else (bind ?packed (append$ ?packed (subseq$ ?multifield 1 (- (length$ ?multifield) 1))))
                     )
                else (bind ?packed (append$ ?packed (subseq$ ?multifield 1 (- (length$ ?multifield) 1))))
            )
            (bind ?multifield (create$ ?current))
           ;(println "2 ?multifield: " ?multifield " ?packed: " ?packed)
        )
        (if (= ?current-index (length$ ?arguments)) then 
           ;(println "3 ?multifield: " ?multifield " ?packed: " ?packed)
            (if (and ?key-argument-exist (> (length$ ?multifield) 2))
                then (bind ?packed (append$ ?packed (first$ ?multifield)))
                     (bind ?packed (append$ ?packed (Multifield (rest$ ?multifield))))
                else (bind ?packed (append$ ?packed ?multifield))
            )
           ;(println "4 ?multifield: " ?multifield " ?packed: " ?packed)
        )
    )
    (return ?packed)
)
(deffunction unmake-packed-arguments ($?arguments)
    (progn$ (?argument ?arguments)
        (if (is-member-of Multifield ?argument) then 
           ;(unmake-packed-arguments (send ?argument get-multifield)) ;;; 不应当递归处理
            (unmake-instance ?argument)
        )
    )
)
(defmethod repeat ((?USER USER) (?count INTEGER))
    (bind ?result (Multifield))
    (loop-for-count ?count
        (bind ?result (append$ ?result ?USER))
    )
    (return ?result)
)
;;; 测试框架
(defclass Assertion (is-a USER)
    (multislot left    )
    (     slot relation)
    (multislot right   )
    (     slot comment )
)
(deffunction REQUIRE (?comment ?left ?relation ?right) (make-instance of Assertion (left ?left) (relation ?relation) (right ?right) (comment ?comment)))
(deffunction REQUIRE_TRUE  (?comment ?expr) (make-instance of Assertion (left ?expr) (relation eq) (right TRUE )(comment ?comment)))
(deffunction REQUIRE_FALSE (?comment ?expr) (make-instance of Assertion (left ?expr) (relation eq) (right FALSE)(comment ?comment)))

(defrule TestCase:SingleField
    (object (is-a Assertion)(left ?left)(relation ?relation)(right ?right)(comment ?comment))
    (test (not (funcall ?relation ?left ?right)))
=>
    (println "[ERROR(TEST:SingleFiled)]["?comment"]: "?left" should ["?relation"] to "?right)
)
(defrule TestCase:MultiField
    (object (is-a Assertion)(left $?left)(relation ?relation)(right $?right)(comment ?comment))
    (test (or  (> (length$ ?left) 1)(> (length$ ?right) 1)))
    (test (not (funcall ?relation ?left ?right)))
=>
    (println "[ERROR(TEST:MultiField)]["?comment"]: "?left" should ["?relation"] to "?right)
)
(defrule TestCase:Clear
    (declare (salience -10000))
    (object (name ?x)(is-a Assertion))
=>
    (unmake-instance ?x)
)

;;; 测试代码
(definstances Utility:Test (of Multifield (multifield
    (REQUIRE Utility:001 1  = 1)
    (REQUIRE Utility:002 1 != 2)

    (REQUIRE Utility:003 "ABC"     str-equal "ABC")
    (REQUIRE Utility:004 "ABC" str-not-equal "DEF")

    (REQUIRE Utility:005 (join$ (create$ A B C)) str-equal "A B C")

    (REQUIRE Utility:006 (map (explode$ "A B C") "(str-cat ?v ?v ?v)") eq (create$ "AAA" "BBB" "CCC"))
    (REQUIRE Utility:007 (map (explode$ "A B C") "(sym-cat ?v ?v ?v)") eq (create$  AAA   BBB   CCC ))

    (REQUIRE Utility:008 (filter (create$ 1 2 3 4 5) "(evenp ?v)") eq (create$ 2 4))
    (REQUIRE Utility:009 (filter (create$ 1 2 3 4 5) "(oddp  ?v)") eq (create$ 1 3 5))

    (REQUIRE_FALSE Utility:010 (key-argument-p hello ))
    (REQUIRE_TRUE  Utility:011 (key-argument-p hello:))

    (REQUIRE_TRUE  Utility:012 (str-starts-with "hello" "hello:"))
    (REQUIRE_FALSE Utility:013 (str-starts-with "world" "hello:"))
    (REQUIRE_TRUE  Utility:014 (str-ends-with ":"  "hello:"))
    (REQUIRE_FALSE Utility:015 (str-ends-with ">"  "hello:"))
    (REQUIRE_TRUE  Utility:016 (str-ends-with "o:" "hello:"))
    (REQUIRE_FALSE Utility:017 (str-ends-with "O:" "hello:"))
    (REQUIRE_TRUE  Utility:018 (str-starts-with hello hello:))
    (REQUIRE_FALSE Utility:019 (str-starts-with world hello:))
    (REQUIRE_TRUE  Utility:020 (str-ends-with :  hello:))
    (REQUIRE_FALSE Utility:021 (str-ends-with >  hello:))
    (REQUIRE_TRUE  Utility:022 (str-ends-with o: hello:))
    (REQUIRE_FALSE Utility:023 (str-ends-with O: hello:))

    (REQUIRE_TRUE  Utility:024 (has-only-one$ (create$ A)))
    (REQUIRE_FALSE Utility:025 (has-only-one$ (create$ A B)))
    (REQUIRE       Utility:026 (the-only-one$ (create$ A)) eq A)

    (REQUIRE       Utility:027 (str-make-first-upper hello) eq "Hello")
    (REQUIRE       Utility:028 (str-make-first-upper World) eq "World")

    (REQUIRE_TRUE  CLIPS:001 (superclassp LEXEME STRING))
    (REQUIRE_TRUE  CLIPS:002 (superclassp LEXEME SYMBOL))

    (REQUIRE_TRUE  CLIPS:003 (superclassp NUMBER INTEGER))
    (REQUIRE_TRUE  CLIPS:004 (superclassp NUMBER FLOAT))

    (REQUIRE Utility:100       (length$ (make-packed-arguments hi: HI hello: xixi haha hehe world: good luck))  =  6)
    (REQUIRE Utility:101        (nth$ 1 (make-packed-arguments hi: HI hello: xixi haha hehe world: good luck))  eq hi:)
    (REQUIRE Utility:102        (nth$ 2 (make-packed-arguments hi: HI hello: xixi haha hehe world: good luck))  eq HI )
    (REQUIRE Utility:103        (nth$ 3 (make-packed-arguments hi: HI hello: xixi haha hehe world: good luck))  eq hello:)
    (REQUIRE Utility:104 (class (nth$ 4 (make-packed-arguments hi: HI hello: xixi haha hehe world: good luck))) eq Multifield)
    (REQUIRE Utility:105        (nth$ 5 (make-packed-arguments hi: HI hello: xixi haha hehe world: good luck))  eq world:)
    (REQUIRE Utility:106 (class (nth$ 6 (make-packed-arguments hi: HI hello: xixi haha hehe world: good luck))) eq Multifield)
    (REQUIRE Utility:107 (send  (nth$ 4 (make-packed-arguments hi: HI hello: xixi haha hehe world: good luck)) get-multifield)
                          eq    (create$ xixi haha hehe))
    (REQUIRE Utility:108 (send  (nth$ 6 (make-packed-arguments hi: HI hello: xixi haha hehe world: good luck)) get-multifield)
                          eq    (create$ good luck))

    (REQUIRE Utility:200       (length$ (make-packed-arguments hi: HI hello: xixi haha hehe world: good))  =  6)
    (REQUIRE Utility:201        (nth$ 1 (make-packed-arguments hi: HI hello: xixi haha hehe world: good))  eq hi:)
    (REQUIRE Utility:202        (nth$ 2 (make-packed-arguments hi: HI hello: xixi haha hehe world: good))  eq HI )
    (REQUIRE Utility:203        (nth$ 3 (make-packed-arguments hi: HI hello: xixi haha hehe world: good))  eq hello:)
    (REQUIRE Utility:204 (class (nth$ 4 (make-packed-arguments hi: HI hello: xixi haha hehe world: good))) eq Multifield)
    (REQUIRE Utility:205        (nth$ 5 (make-packed-arguments hi: HI hello: xixi haha hehe world: good))  eq world:)
    (REQUIRE Utility:206        (nth$ 6 (make-packed-arguments hi: HI hello: xixi haha hehe world: good))  eq good)
    (REQUIRE Utility:207 (send  (nth$ 4 (make-packed-arguments hi: HI hello: xixi haha hehe world: good)) get-multifield)
                          eq    (create$ xixi haha hehe))

    (REQUIRE Utility:300       (length$ (make-packed-arguments hi: HI hello: xixi haha hehe world:))  =  5)
    (REQUIRE Utility:301        (nth$ 1 (make-packed-arguments hi: HI hello: xixi haha hehe world:))  eq hi:)
    (REQUIRE Utility:302        (nth$ 2 (make-packed-arguments hi: HI hello: xixi haha hehe world:))  eq HI )
    (REQUIRE Utility:303        (nth$ 3 (make-packed-arguments hi: HI hello: xixi haha hehe world:))  eq hello:)
    (REQUIRE Utility:304 (class (nth$ 4 (make-packed-arguments hi: HI hello: xixi haha hehe world:))) eq Multifield)
    (REQUIRE Utility:305        (nth$ 5 (make-packed-arguments hi: HI hello: xixi haha hehe world:))  eq world:)
    (REQUIRE Utility:306 (send  (nth$ 4 (make-packed-arguments hi: HI hello: xixi haha hehe world: good)) get-multifield)
                          eq    (create$ xixi haha hehe))

    (REQUIRE Utility:400       (length$ (make-packed-arguments A B C D hi: HI))  =  6)
    (REQUIRE Utility:401        (nth$ 1 (make-packed-arguments A B C D hi: HI))  eq A)
    (REQUIRE Utility:402        (nth$ 2 (make-packed-arguments A B C D hi: HI))  eq B)
    (REQUIRE Utility:403        (nth$ 3 (make-packed-arguments A B C D hi: HI))  eq C)
    (REQUIRE Utility:404        (nth$ 4 (make-packed-arguments A B C D hi: HI))  eq D)
    (REQUIRE Utility:405        (nth$ 5 (make-packed-arguments A B C D hi: HI))  eq hi:)
    (REQUIRE Utility:406        (nth$ 6 (make-packed-arguments A B C D hi: HI))  eq HI)


    (REQUIRE Utility:500        (length$ (make-packed-arguments A B C D hi: HI hello: xixi haha hehe world: good luck))  = 10)
    (REQUIRE Utility:501        (nth$  1 (make-packed-arguments A B C D hi: HI hello: xixi haha hehe world: good luck))  eq A)
    (REQUIRE Utility:502        (nth$  2 (make-packed-arguments A B C D hi: HI hello: xixi haha hehe world: good luck))  eq B)
    (REQUIRE Utility:503        (nth$  3 (make-packed-arguments A B C D hi: HI hello: xixi haha hehe world: good luck))  eq C)
    (REQUIRE Utility:504        (nth$  4 (make-packed-arguments A B C D hi: HI hello: xixi haha hehe world: good luck))  eq D)
    (REQUIRE Utility:505        (nth$  5 (make-packed-arguments A B C D hi: HI hello: xixi haha hehe world: good luck))  eq hi:)
    (REQUIRE Utility:506        (nth$  6 (make-packed-arguments A B C D hi: HI hello: xixi haha hehe world: good luck))  eq HI)
    (REQUIRE Utility:507        (nth$  7 (make-packed-arguments A B C D hi: HI hello: xixi haha hehe world: good luck))  eq hello:)
    (REQUIRE Utility:508 (class (nth$  8 (make-packed-arguments A B C D hi: HI hello: xixi haha hehe world: good luck))) eq Multifield)
    (REQUIRE Utility:509        (nth$  9 (make-packed-arguments A B C D hi: HI hello: xixi haha hehe world: good luck))  eq world:)
    (REQUIRE Utility:510 (class (nth$ 10 (make-packed-arguments A B C D hi: HI hello: xixi haha hehe world: good luck))) eq Multifield)
    (REQUIRE Utility:511 (send  (nth$  8 (make-packed-arguments A B C D hi: HI hello: xixi haha hehe world: good luck)) get-multifield)
                          eq    (create$ xixi haha hehe))
    (REQUIRE Utility:512 (send  (nth$ 10 (make-packed-arguments A B C D hi: HI hello: xixi haha hehe world: good luck)) get-multifield)
                          eq    (create$ good luck))


    (REQUIRE Utility:600        (length$ (make-packed-arguments A B C D))  =  4)
    (REQUIRE Utility:601        (nth$  1 (make-packed-arguments A B C D))  eq A)
    (REQUIRE Utility:602        (nth$  2 (make-packed-arguments A B C D))  eq B)
    (REQUIRE Utility:603        (nth$  3 (make-packed-arguments A B C D))  eq C)
    (REQUIRE Utility:604        (nth$  4 (make-packed-arguments A B C D))  eq D)
)))
