;;; vim:expandtab autoindent
;;; map <buffer> \\ :update<CR>:1tabnext<CR>:2wincmd w<CR>:silent normal \\<CR>:3tabnext<CR>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; table core definitions
(defclass TABLE (is-a USER)(pattern-match non-reactive)
    (     slot repeat   (type INTEGER)(default 1))
    (multislot TRS    (type INSTANCE)(allowed-classes TR))
    (slot BORDER        (type INTEGER)(default 0))
    (slot CELLBORDER    (type INTEGER)(default 1))
    (slot CELLSPACING   (type INTEGER)(default 0))
    (slot CELLPADDING   (type INTEGER)(default 2))
    (slot BGCOLOR       (type SYMBOL))
    (slot COLOR         (type LEXEME)(default gray))
    (slot SIDES         (type LEXEME)); L T R B
    (slot STYLE         (type SYMBOL)(allowed-symbols nil ROUNDED RADIAL))
    (slot FIXEDSIZE     (type SYMBOL)(allowed-symbols FALSE TRUE)(default FALSE))
    (slot WIDTH         (type INTEGER)(default 0))
    (slot HEIGHT        (type INTEGER)(default 0))
    (slot VALIGN        (type SYMBOL)(allowed-symbols nil MIDDLE BOTTOM TOP))
    (slot ALIGN         (type SYMBOL)(allowed-symbols nil CENTER LEFT RIGHT))
)
(defclass TR (is-a USER)(pattern-match non-reactive)
    (     slot repeat   (type INTEGER)(default 1))
    (multislot TDS      (type INSTANCE)(allowed-classes TD))
)
(defclass TD (is-a USER)(pattern-match non-reactive)
    (slot CONTENT       (type INSTANCE)(allowed-classes TEXT TABLE))
    (slot BORDER        (type INTEGER)(default -1))
    (slot ROWSPAN       (type INTEGER))
    (slot COLSPAN       (type INTEGER))
    (slot ALIGN         (type SYMBOL)(allowed-symbols nil CENTER LEFT RIGHT TEXT))
    (slot BGCOLOR       (type SYMBOL))
    (slot COLOR         (type SYMBOL))
    (slot PORT          (type LEXEME))
    (slot SIDES         (type LEXEME)); L T R B
    (slot STYLE         (type SYMBOL)(allowed-symbols nil ROUNDED RADIAL INVIS))
    (slot FIXEDSIZE     (type SYMBOL)(allowed-symbols FALSE TRUE)(default FALSE))
    (slot WIDTH         (type INTEGER)(default 0))
    (slot HEIGHT        (type INTEGER)(default 0))
    (slot BALIGN        (type SYMBOL)(allowed-symbols nil CENTER LEFT RIGHT))
    (slot VALIGN        (type SYMBOL)(allowed-symbols nil MIDDLE BOTTOM TOP))
)
(defclass TEXT (is-a USER)(pattern-match non-reactive)
    (slot 文本          (type LEXEME NUMBER))
    (slot COLOR         (type LEXEME))
    (slot POINT-SIZE    (type INTEGER))
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; message-handler for delete
(defmessage-handler TABLE delete before () (progn$ (?v ?self:TRS    ) (if (instance-existp ?v) then (send ?v delete))))
(defmessage-handler TR    delete before () (progn$ (?v ?self:TDS    ) (if (instance-existp ?v) then (send ?v delete))))
(defmessage-handler TD    delete before () (bind    ?v ?self:CONTENT) (if (instance-existp ?v) then (send ?v delete)) )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; message-handler for graphviz
(defmessage-handler TABLE graphviz ()
    (bind ?text (create$))
    (bind ?BGCOLOR   (if (neq   nil ?self:BGCOLOR  ) then (str-cat (S)  BGCOLOR=(Q ?self:BGCOLOR  )) else ""))
    (bind ?COLOR     (if (neq   nil ?self:COLOR    ) then (str-cat (S)    COLOR=(Q ?self:COLOR    )) else ""))
    (bind ?SIDES     (if (neq   nil ?self:SIDES    ) then (str-cat (S)    SIDES=(Q ?self:SIDES    )) else ""))
    (bind ?STYLE     (if (neq   nil ?self:STYLE    ) then (str-cat (S)    STYLE=(Q ?self:STYLE    )) else ""))
    (bind ?FIXEDSIZE (if (neq FALSE ?self:FIXEDSIZE) then (str-cat (S)FIXEDSIZE=(Q ?self:FIXEDSIZE)) else ""))
    (bind ?WIDTH     (if (!=      0 ?self:WIDTH    ) then (str-cat (S)    WIDTH=(Q ?self:WIDTH    )) else ""))
    (bind ?HEIGHT    (if (!=      0 ?self:HEIGHT   ) then (str-cat (S)   HEIGHT=(Q ?self:HEIGHT   )) else ""))
    (bind ?VALIGN    (if (neq   nil ?self:VALIGN   ) then (str-cat (S)   VALIGN=(Q ?self:VALIGN   )) else ""))
    (bind ?ALIGN     (if (neq   nil ?self:ALIGN    ) then (str-cat (S)    ALIGN=(Q ?self:ALIGN    )) else ""))
    (bind ?text (append$ ?text (str-cat <TABLE(S)CELLBORDER =(Q ?self:CELLBORDER)
                                              (S)CELLSPACING=(Q ?self:CELLSPACING)
                                              (S)CELLPADDING=(Q ?self:CELLPADDING)
                                              (S)     BORDER=(Q ?self:BORDER)
                                              (I ?BGCOLOR)
                                              (I ?COLOR)
                                              (I ?SIDES)
                                              (I ?STYLE)
                                              (I ?FIXEDSIZE)
                                              (I ?WIDTH)
                                              (I ?HEIGHT)
                                              (I ?VALIGN)
                                              (I ?ALIGN)>)))
    (progn$ (?v ?self:TRS) (bind ?text (append$ ?text (send ?v graphviz))))
    (bind ?text (append$ ?text (str-cat </TABLE>)))
    (return ?text)
)
(defmessage-handler TR graphviz ()
    (bind ?text (create$))
    (bind ?text (append$ ?text (str-cat < TR>)))
    (progn$ (?v ?self:TDS) (bind ?text (append$ ?text (send ?v graphviz))))
    (bind ?text (append$ ?text (str-cat </TR>)))
    (return ?text)
)
(defmessage-handler TD graphviz ()
    (bind ?BORDER    (if (!=     -1 ?self:BORDER   ) then (str-cat (S)   BORDER=(Q ?self:BORDER   )) else ""))
    (bind ?COLSPAN   (if (!=      0 ?self:COLSPAN  ) then (str-cat (S)  COLSPAN=(Q ?self:COLSPAN  )) else ""))
    (bind ?ROWSPAN   (if (!=      0 ?self:ROWSPAN  ) then (str-cat (S)  ROWSPAN=(Q ?self:ROWSPAN  )) else ""))
    (bind ?ALIGN     (if (neq   nil ?self:ALIGN    ) then (str-cat (S)    ALIGN=(Q ?self:ALIGN    )) else ""))
    (bind ?BGCOLOR   (if (neq   nil ?self:BGCOLOR  ) then (str-cat (S)  BGCOLOR=(Q ?self:BGCOLOR  )) else ""))
    (bind ?PORT      (if (neq   nil ?self:PORT     ) then (str-cat (S)     PORT=(Q ?self:PORT     )) else ""))
    (bind ?COLOR     (if (neq   nil ?self:COLOR    ) then (str-cat (S)    COLOR=(Q ?self:COLOR    )) else ""))
    (bind ?SIDES     (if (neq   nil ?self:SIDES    ) then (str-cat (S)    SIDES=(Q ?self:SIDES    )) else ""))
    (bind ?STYLE     (if (neq   nil ?self:STYLE    ) then (str-cat (S)    STYLE=(Q ?self:STYLE    )) else ""))
    (bind ?FIXEDSIZE (if (neq FALSE ?self:FIXEDSIZE) then (str-cat (S)FIXEDSIZE=(Q ?self:FIXEDSIZE)) else ""))
    (bind ?WIDTH     (if (!=      0 ?self:WIDTH    ) then (str-cat (S)    WIDTH=(Q ?self:WIDTH    )) else ""))
    (bind ?HEIGHT    (if (!=      0 ?self:HEIGHT   ) then (str-cat (S)   HEIGHT=(Q ?self:HEIGHT   )) else ""))
    (bind ?BALIGN    (if (neq   nil ?self:BALIGN   ) then (str-cat (S)   BALIGN=(Q ?self:BALIGN   )) else ""))
    (bind ?VALIGN    (if (neq   nil ?self:VALIGN   ) then (str-cat (S)   VALIGN=(Q ?self:VALIGN   )) else ""))
    (bind ?text (create$))
    (bind ?text (append$ ?text (str-cat < TD(I ?BORDER)
                                            (I ?ROWSPAN)
                                            (I ?COLSPAN)
                                            (I ?ALIGN)
                                            (I ?BGCOLOR)
                                            (I ?PORT)
                                            (I ?COLOR)
                                            (I ?SIDES)
                                            (I ?STYLE)
                                            (I ?FIXEDSIZE)
                                            (I ?WIDTH)
                                            (I ?HEIGHT)
                                            (I ?BALIGN)
                                            (I ?VALIGN)>)))
    (bind ?text (append$ ?text (send ?self:CONTENT graphviz)))
    (bind ?text (append$ ?text (str-cat </TD>)))
    (return ?text)
)
(defmessage-handler TEXT graphviz ()
    (bind ?COLOR      (if (neq nil ?self:COLOR     ) then (str-cat (S)       COLOR=(Q ?self:COLOR     )) else ""))
    (bind ?POINT-SIZE (if (!=  0   ?self:POINT-SIZE) then (str-cat (S)  POINT-SIZE=(Q ?self:POINT-SIZE)) else ""))
    (if (!= 0 (str-length (str-cat ?COLOR ?POINT-SIZE))) then
        (return (str-cat <FONT(I ?COLOR)(I ?POINT-SIZE)>(I ?self:文本)</FONT>))
    )
    (return ?self:文本)
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; APplication Interface
(defgeneric #TABLE)
(defgeneric #TR)
(defgeneric #TD)
(defgeneric #TEXT)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmethod  #TABLE 10000 ((?self USER) $?X) (halt-method-with-arguments #TABLE ?self (expand$ ?X)))
(defmethod  #TR    10000 ((?self USER) $?X) (halt-method-with-arguments #TR    ?self (expand$ ?X)))
(defmethod  #TD    10000 ((?self USER) $?X) (halt-method-with-arguments #TD    ?self (expand$ ?X)))
(defmethod  #TEXT  10000 ((?self USER) $?X) (halt-method-with-arguments #TEXT  ?self (expand$ ?X)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deffunction TABLE ($?X) (#TABLE (make-instance of TABLE) (expand$ ?X)))
(deffunction TR    ($?X) (#TR    (make-instance of TR   ) (expand$ ?X)))
(deffunction TD    ($?X) (#TD    (make-instance of TD   ) (expand$ ?X)))
(deffunction TEXT  ($?X) (#TEXT  (make-instance of TEXT ) (expand$ ?X)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; #TABLE
(defmethod #TABLE 100 ((?self TABLE))
    (bind ?TRS (send ?self get-TRS))
    (loop-for-count (- (send ?self get-repeat) 1)
        (slot-append$ ?self TRS ?TRS)
    )
    (return ?self)
)
(defmethod #TABLE 101 ((?self TABLE) (?k (eq ?k      repeat:)) ?v $?X) (modify-instance ?self (     repeat ?v)) (#TABLE ?self (expand$ ?X)))
(defmethod #TABLE 102 ((?self TABLE) (?v TR)                      $?X) (slot-append$    ?self          TRS ?v ) (#TABLE ?self (expand$ ?X)))
(defmethod #TABLE 103 ((?self TABLE) (?k (eq ?k      BORDER:)) ?v $?X) (modify-instance ?self (     BORDER ?v)) (#TABLE ?self (expand$ ?X)))
(defmethod #TABLE 104 ((?self TABLE) (?k (eq ?k  CELLBORDER:)) ?v $?X) (modify-instance ?self ( CELLBORDER ?v)) (#TABLE ?self (expand$ ?X)))
(defmethod #TABLE 105 ((?self TABLE) (?k (eq ?k CELLSPACING:)) ?v $?X) (modify-instance ?self (CELLSPACING ?v)) (#TABLE ?self (expand$ ?X)))
(defmethod #TABLE 106 ((?self TABLE) (?k (eq ?k CELLPADDING:)) ?v $?X) (modify-instance ?self (CELLPADDING ?v)) (#TABLE ?self (expand$ ?X)))
(defmethod #TABLE 107 ((?self TABLE) (?k (eq ?k       COLOR:)) ?v $?X) (modify-instance ?self (      COLOR ?v)) (#TABLE ?self (expand$ ?X)))
(defmethod #TABLE 108 ((?self TABLE) (?k (eq ?k     BGCOLOR:)) ?v $?X) (modify-instance ?self (    BGCOLOR ?v)) (#TABLE ?self (expand$ ?X)))
(defmethod #TABLE 109 ((?self TABLE) (?k (eq ?k       SIDES:)) ?v $?X) (modify-instance ?self (      SIDES ?v)) (#TABLE ?self (expand$ ?X)))
(defmethod #TABLE 110 ((?self TABLE) (?k (eq ?k       STYLE:)) ?v $?X) (modify-instance ?self (      STYLE ?v)) (#TABLE ?self (expand$ ?X)))
(defmethod #TABLE 111 ((?self TABLE) (?k (eq ?k   FIXEDSIZE:)) ?v $?X) (modify-instance ?self (  FIXEDSIZE ?v)) (#TABLE ?self (expand$ ?X)))
(defmethod #TABLE 112 ((?self TABLE) (?k (eq ?k       WIDTH:)) ?v $?X) (modify-instance ?self (      WIDTH ?v)) (#TABLE ?self (expand$ ?X)))
(defmethod #TABLE 113 ((?self TABLE) (?k (eq ?k      HEIGHT:)) ?v $?X) (modify-instance ?self (     HEIGHT ?v)) (#TABLE ?self (expand$ ?X)))
(defmethod #TABLE 114 ((?self TABLE) (?k (eq ?k      VALIGN:)) ?v $?X) (modify-instance ?self (     VALIGN ?v)) (#TABLE ?self (expand$ ?X)))
(defmethod #TABLE 115 ((?self TABLE) (?k (eq ?k       ALIGN:)) ?v $?X) (modify-instance ?self (      ALIGN ?v)) (#TABLE ?self (expand$ ?X)))
;;; #TR
(defmethod #TR 100 ((?self TR))
    (bind ?TDS (send ?self get-TDS))
    (loop-for-count (- (send ?self get-repeat) 1)
        (slot-append$ ?self TDS ?TDS)
    )
    (return ?self)
)
(defmethod #TR 101 ((?self TR) (?k (eq ?k repeat:)) ?v $?X) (modify-instance ?self (repeat ?v)) (#TR ?self (expand$ ?X)))
(defmethod #TR 102 ((?self TR) (?v TD)                 $?X) (slot-append$    ?self  TDS    ?v ) (#TR ?self (expand$ ?X)))
;;; #TD
(defmethod #TD 100 ((?self TD))(return ?self))
(defmethod #TD 101 ((?self TD) (?v LEXEME (not (key-argument-p ?v))) $?X) (#TD ?self (TEXT ?v) (expand$ ?X)))
(defmethod #TD 102 ((?self TD) (?v NUMBER)                           $?X) (#TD ?self (TEXT ?v) (expand$ ?X)))
(defmethod #TD 103 ((?self TD) (?v TEXT TABLE)                       $?X) (modify-instance ?self (  CONTENT ?v)) (#TD ?self (expand$ ?X)))
(defmethod #TD 104 ((?self TD) (?k (eq ?k   COLSPAN:))         ?v    $?X) (modify-instance ?self (  COLSPAN ?v)) (#TD ?self (expand$ ?X)))
(defmethod #TD 105 ((?self TD) (?k (eq ?k   ROWSPAN:))         ?v    $?X) (modify-instance ?self (  ROWSPAN ?v)) (#TD ?self (expand$ ?X)))
(defmethod #TD 106 ((?self TD) (?k (eq ?k     ALIGN:))         ?v    $?X) (modify-instance ?self (    ALIGN ?v)) (#TD ?self (expand$ ?X)))
(defmethod #TD 107 ((?self TD) (?k (eq ?k   BGCOLOR:))         ?v    $?X) (modify-instance ?self (  BGCOLOR ?v)) (#TD ?self (expand$ ?X)))
(defmethod #TD 108 ((?self TD) (?k (eq ?k      PORT:))         ?v    $?X) (modify-instance ?self (     PORT ?v)) (#TD ?self (expand$ ?X)))
(defmethod #TD 109 ((?self TD) (?k (eq ?k     COLOR:))         ?v    $?X) (modify-instance ?self (    COLOR ?v)) (#TD ?self (expand$ ?X)))
(defmethod #TD 110 ((?self TD) (?k (eq ?k     SIDES:))         ?v    $?X) (modify-instance ?self (    SIDES ?v)) (#TD ?self (expand$ ?X)))
(defmethod #TD 111 ((?self TD) (?k (eq ?k     STYLE:))         ?v    $?X) (modify-instance ?self (    STYLE ?v)) (#TD ?self (expand$ ?X)))
(defmethod #TD 112 ((?self TD) (?k (eq ?k    BORDER:))         ?v    $?X) (modify-instance ?self (   BORDER ?v)) (#TD ?self (expand$ ?X)))
(defmethod #TD 113 ((?self TD) (?k (eq ?k FIXEDSIZE:))         ?v    $?X) (modify-instance ?self (FIXEDSIZE ?v)) (#TD ?self (expand$ ?X)))
(defmethod #TD 114 ((?self TD) (?k (eq ?k     WIDTH:))         ?v    $?X) (modify-instance ?self (    WIDTH ?v)) (#TD ?self (expand$ ?X)))
(defmethod #TD 115 ((?self TD) (?k (eq ?k    HEIGHT:))         ?v    $?X) (modify-instance ?self (   HEIGHT ?v)) (#TD ?self (expand$ ?X)))
(defmethod #TD 116 ((?self TD) (?k (eq ?k    VALIGN:))         ?v    $?X) (modify-instance ?self (   VALIGN ?v)) (#TD ?self (expand$ ?X)))
;;; #TEXT
(defmethod #TEXT 100 ((?self TEXT))(return ?self))
(defmethod #TEXT 101 ((?self TEXT) (?v LEXEME (not (key-argument-p ?v))) $?X) (modify-instance ?self (文本       ?v)) (#TEXT ?self (expand$ ?X)))
(defmethod #TEXT 102 ((?self TEXT) (?v NUMBER)                           $?X) (modify-instance ?self (文本       ?v)) (#TEXT ?self (expand$ ?X)))
(defmethod #TEXT 103 ((?self TEXT) (?k (eq ?k       文本:))        ?v    $?X) (modify-instance ?self (文本       ?v)) (#TEXT ?self (expand$ ?X)))
(defmethod #TEXT 104 ((?self TEXT) (?k (eq ?k      COLOR:))        ?v    $?X) (modify-instance ?self (COLOR      ?v)) (#TEXT ?self (expand$ ?X)))
(defmethod #TEXT 105 ((?self TEXT) (?k (eq ?k POINT-SIZE:))        ?v    $?X) (modify-instance ?self (POINT-SIZE ?v)) (#TEXT ?self (expand$ ?X)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defclass GRAPH (is-a USER)
    (slot kind          (type SYMBOL)(allowed-symbols digraph graph)(default digraph))
    (slot strict        (type SYMBOL)(allowed-symbols FALSE TRUE)(default FALSE))
    (slot owner         (type INSTANCE))
    (slot named         (type LEXEME)(default-dynamic (gensym*)))
    (slot uuid          (type LEXEME)(default-dynamic (gensym*)))
    (slot file:output   (type LEXEME)(default-dynamic (gensym*)))
    (slot file:active   (type LEXEME)(allowed-symbols FALSE TRUE)(default FALSE))

    (multislot attributes (type LEXEME))
)
(defclass NODE  (is-a USER)
    (slot owner (type INSTANCE       )(visibility public)(allowed-classes GRAPH))
    (slot named (type LEXEME         )(visibility public)(default-dynamic (gensym*)))
    (slot uuid  (type LEXEME         )(default-dynamic (gensym*)))
    (slot label (type LEXEME INSTANCE)(visibility public)(default-dynamic (gensym*))(allowed-classes TABLE))

    (multislot attributes (type LEXEME)(visibility public))
)
(defclass EDGE  (is-a USER)
    (slot owner         (type INSTANCE)(allowed-classes GRAPH))
    (slot uuid          (type LEXEME         )(default-dynamic (gensym*)))
    (slot node:source   (type INSTANCE)(allowed-classes NODE ))
    (slot node:target   (type INSTANCE)(allowed-classes NODE ))
    (slot port:source   (type LEXEME  ))
    (slot port:target   (type LEXEME  ))

    (multislot attributes (type LEXEME))
)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmessage-handler GRAPH graphviz ()
    (bind ?graph (if (eq [nil] ?self:owner) then ?self:kind else subgraph))
    (bind ?M (create$))
    (bind ?M (append-cat$ ?M (indent  0) (I ?graph)(S)(I ?self:named)(S){))
    (bind ?M (append$     ?M (indent$ 1 ?self:attributes)))
    ;;; NODE
    (do-for-all-instances ((?node NODE))(eq (instance-name ?self)(send ?node get-owner))
        (bind ?M (append$ ?M (indent$ 1 (send ?node graphviz))))
    )
    ;;; EDGE
    (do-for-all-instances ((?edge EDGE))(eq (instance-name ?self)(send ?edge get-owner))
        (bind ?M (append$ ?M (indent$ 1 (send ?edge graphviz))))
    )
    ;;; SUBGRAPH
    (do-for-all-instances ((?subgraph GRAPH))(eq (instance-name ?self)(send ?subgraph get-owner))
        (bind ?M (append$ ?M (indent$ 1 (send ?subgraph graphviz))))
    )
    (bind ?M (append-cat$ ?M (indent  0) }))
    (return ?M)
)
(defmessage-handler NODE graphviz ()
    (bind ?label        (if (instancep ?self:label)
                            then (str-cat label=<(join$ (send ?self:label graphviz) "")>)
                            else (str-cat label=(Q ?self:label))))
    (bind ?attributes   (if (not-empty$ ?self:attributes)
                            then (str-cat (S)(join$ ?self:attributes))
                            else ""))
    (bind ?M (create$))
    (bind ?M (append-cat$ ?M (indent 0) (Q ?self:named)(S) [(I ?label)(I ?attributes)] ))
    (return ?M)
)
(defmessage-handler EDGE graphviz ()
    (bind ?source       (send ?self:node:source get-named))
    (bind ?target       (send ?self:node:target get-named))
    (bind ?attributes   (if (not-empty$ ?self:attributes) then (str-cat (join$ ?self:attributes)) else ""))
    (bind ?M (create$))
    (bind ?M (append-cat$ ?M (indent 0) (Q ?source)(S)->(S)(Q ?target)(S)[(I ?attributes)]))
    (return ?M)
)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defgeneric #GRAPH)
(defgeneric #NODE)
(defgeneric #EDGE)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmethod  #GRAPH ((?self USER) $?X) (halt-method-with-arguments #GRAPH ?self (expand$ ?X)))
(defmethod  #NODE  ((?self USER) $?X) (halt-method-with-arguments #NODE  ?self (expand$ ?X)))
(defmethod  #EDGE  ((?self USER) $?X) (halt-method-with-arguments #EDGE  ?self (expand$ ?X)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(deffunction GRAPH ($?arguments) (#GRAPH (make-instance of GRAPH) (expand$ ?arguments)))
(deffunction NODE  ($?arguments) (#NODE  (make-instance of NODE ) (expand$ ?arguments)))
(deffunction EDGE  ($?arguments) (#EDGE  (make-instance of EDGE ) (expand$ ?arguments)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmethod #GRAPH 100 ((?self GRAPH))(return ?self))
(defmethod #GRAPH 101 ((?self GRAPH) (?v GRAPH) $?X) (modify-instance ?v (owner ?self)) (#GRAPH ?self (expand$ ?X)))
(defmethod #GRAPH 102 ((?self GRAPH) (?v NODE ) $?X) (modify-instance ?v (owner ?self)) (#GRAPH ?self (expand$ ?X)))
(defmethod #GRAPH 103 ((?self GRAPH) (?v EDGE ) $?X) (modify-instance ?v (owner ?self)) (#GRAPH ?self (expand$ ?X)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmethod #NODE  100 ((?self NODE))(return ?self))
(defmethod #NODE  101 ((?self NODE)(?k (eq ?k owner:)) (?v GRAPH)        $?X) (modify-instance ?self (owner ?v))
                                                                              (#NODE ?self (expand$ ?X)))
(defmethod #NODE  102 ((?self NODE)(?k (eq ?k label:)) (?v LEXEME)       $?X) (modify-instance ?self (label ?v))
                                                                              (#NODE ?self (expand$ ?X)))
(defmethod #NODE  102 ((?self NODE)(?k (eq ?k label:)) (?v TABLE )       $?X) (modify-instance ?self (label ?v))
                                                                              (#NODE ?self (expand$ ?X)))
(defmethod #NODE  103 ((?self NODE)(?v LEXEME (not (key-argument-p ?v))) $?X) (#NODE ?self label: ?v (expand$ ?X)))
(defmethod #NODE  104 ((?self NODE)(?v TABLE )                           $?X) (#NODE ?self label: ?v (expand$ ?X)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmethod #EDGE  100 ((?self EDGE))(return ?self))
(defmethod #EDGE  101 ((?self EDGE)(?A NODE)(?B NODE) $?X) (modify-instance ?self (node:source ?A) (node:target ?B))
                                                           (#EDGE ?self (expand$ ?X)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defclass BUTTON (is-a TABLE)
    (slot title (type LEXEME))
)
(deffunction BUTTON ($?X) (#TABLE (make-instance of BUTTON (BORDER 0)(STYLE ROUNDED)) (expand$ ?X)))
(defmethod  #TABLE 1000 ((?self BUTTON))
    (slot-append$ ?self TRS (TR (TD (TEXT (send ?self get-title)) STYLE: ROUNDED BGCOLOR: gray95)))
    (return ?self)
)
(defmethod  #TABLE 1001 ((?self BUTTON)(?k (eq ?k title:))             ?v    $?X) (modify-instance ?self (title ?v))
                                                                                  (#TABLE ?self           (expand$ ?X)))
(defmethod  #TABLE 1002 ((?self BUTTON)(?v LEXEME (not (key-argument-p ?v))) $?X) (#TABLE ?self title: ?v (expand$ ?X)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defclass CHECK  (is-a BUTTON)
    (slot checked (type SYMBOL)(allowed-symbols FALSE TRUE)(default FALSE))
)
(deffunction CHECK ($?X) (#TABLE (make-instance of CHECK (BORDER 0)(title selected)) (expand$ ?X)))
(defmethod  #TABLE 1100 ((?self CHECK))
    (bind ?status (if (send ?self get-checked) then "&#x2611;" else "&#x2612;"))
    (slot-append$ ?self TRS (TR (TD (TEXT (str-cat (I ?status)(S)(send ?self get-title))))))
    (return ?self)
)
(defmethod  #TABLE 1101 ((?self CHECK)(?k (eq ?k checked:)) ?v $?X) (modify-instance ?self (checked ?v))
                                                                    (#TABLE ?self (expand$ ?X)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defclass RADIO  (is-a BUTTON)
    (slot selected (type SYMBOL)(allowed-symbols FALSE TRUE)(default FALSE))
)
(deffunction RADIO ($?X) (#TABLE (make-instance of RADIO (BORDER 0)) (expand$ ?X)))
(defmethod  #TABLE 1200 ((?self RADIO))
    (bind ?status (if (send ?self get-selected) then "&#x25C9;" else "&#x25CE;"))
    (slot-append$ ?self TRS (TR (TD (TEXT (str-cat (I ?status)(S)(send ?self get-title))))))
    (return ?self)
)
(defmethod  #TABLE 1201 ((?self RADIO)(?k (eq ?k selected:)) ?v $?X) (modify-instance ?self (selected ?v))
                                                                     (#TABLE ?self (expand$ ?X)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defclass SWITCH (is-a BUTTON)
    (slot status (type SYMBOL)(allowed-symbols OFF ON)(default OFF))
)
(deffunction SWITCH ($?X) (#TABLE (make-instance of SWITCH (BORDER      0)
                                                           (STYLE       ROUNDED)
                                                           (CELLSPACING 1)
                                                           (CELLBORDER  0)) (expand$ ?X)))
(defmethod  #TABLE 1300 ((?self SWITCH))
    (bind ?title  (send ?self get-title ))
    (bind ?status (send ?self get-status))
    (slot-append$ ?self TRS (switch ?status
        (case ON  then (TR (TD (TEXT ON    ))
                           (TD (TEXT ?title) BORDER: 1 STYLE: ROUNDED BGCOLOR: white)))
        (case OFF then (TR (TD (TEXT ?title) BORDER: 1 STYLE: ROUNDED BGCOLOR: white)
                           (TD (TEXT OFF   ))))
    ))
    (modify-instance ?self (BGCOLOR (switch ?status
        (case ON  then green )
        (case OFF then gray80)
    )))
    (return ?self)
)
(defmethod  #TABLE 1301 ((?self SWITCH)(?k (eq ?k status:)) ?v $?X) (modify-instance ?self (status ?v))
                                                                     (#TABLE ?self (expand$ ?X)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defclass LIST (is-a TABLE)
    (     slot direction (type SYMBOL  )(allowed-symbols horizontal vertical))
    (     slot repeat    (type INTEGER )(default 0))
    (multislot children  (type INSTANCE)(allowed-classes TEXT TABLE))
)
(deffunction LIST ($?X) (#TABLE (make-instance of LIST (BORDER 0)) (expand$ ?X)))
(defmethod  #TABLE 2000 ((?self LIST))
    (bind ?n (max 1 (send ?self get-repeat)))
    ;;; 下面的loop-for-count会导致delete的时候，发生重复delete：因为出现了共享的TEXT或者TABLE
    (switch (send ?self get-direction)
        (case vertical   then 
            (loop-for-count ?n (progn$ (?v (send ?self get-children)) (slot-append$ ?self TRS (TR (TD ?v)))))
        )
        (case horizontal then (bind ?TR (TR)) (slot-append$ ?self TRS ?TR)
            (loop-for-count ?n (progn$ (?v (send ?self get-children)) (slot-append$ ?TR TDS (TD ?v))))
        )
    )
    (return ?self)
)
(defmethod #TABLE 2001 ((?self LIST)(?k (eq ?k direction:)) ?v $?X) (modify-instance ?self (directional ?v))
                                                                    (#TABLE ?self (expand$ ?X)))
(defmethod #TABLE 2002 ((?self LIST)(?v TEXT TABLE)            $?X) (slot-append$ ?self children ?v)
                                                                    (#TABLE ?self (expand$ ?X)))
(defmethod #TABLE 2003 ((?self LIST)(?k (eq ?k    repeat:)) ?v $?X) (modify-instance ?self (repeat ?v))
                                                                     (#TABLE ?self (expand$ ?X)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defclass    HLIST (is-a LIST))
(deffunction HLIST ($?X) (#TABLE (make-instance of HLIST (BORDER 0)(direction horizontal)) (expand$ ?X)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defclass    VLIST (is-a LIST))
(deffunction VLIST ($?X) (#TABLE (make-instance of VLIST (BORDER 0)(direction vertical  )) (expand$ ?X)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defclass    IMAGE (is-a TABLE)
    (slot text      (type LEXEME )(default "&#x272B;"))
    (slot rows      (type INTEGER)(default 2))
    (slot columns   (type INTEGER)(default 2))
)
(deffunction IMAGE ($?X) (#TABLE (make-instance of IMAGE (CELLBORDER 0)(BGCOLOR gray90)) (expand$ ?X)))
(defmethod #TABLE 3000 ((?self IMAGE))
    (loop-for-count (send ?self get-rows)
        (bind ?TR (TR))
        (loop-for-count (send ?self get-columns)
            (slot-append$ ?TR TDS (TD (TEXT (send ?self get-text))))
        )
        (slot-append$ ?self TRS ?TR)
    )
    (return ?self)
)
(defmethod #TABLE  3001 ((?self IMAGE) (?k (eq ?k    rows:)) (?v INTEGER)    $?X) (modify-instance ?self (rows    ?v)) (#TABLE ?self (expand$ ?X)))
(defmethod #TABLE  3002 ((?self IMAGE) (?k (eq ?k columns:)) (?v INTEGER)    $?X) (modify-instance ?self (columns ?v)) (#TABLE ?self (expand$ ?X)))
(defmethod #TABLE  3003 ((?self IMAGE) (?k (eq ?k    cols:)) (?v INTEGER)    $?X) (modify-instance ?self (columns ?v)) (#TABLE ?self (expand$ ?X)))
(defmethod #TABLE  3004 ((?self IMAGE) (?k (eq ?k    text:)) (?v INTEGER)    $?X) (modify-instance ?self (text    ?v)) (#TABLE ?self (expand$ ?X)))
(defmethod #TABLE  3005 ((?self IMAGE) (?v LEXEME (not (key-argument-p ?v))) $?X) (modify-instance ?self (text    ?v)) (#TABLE ?self (expand$ ?X)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defclass FORM  (is-a VLIST)
    (multislot left   (type INSTANCE)(allowed-classes TEXT TABLE))
    (multislot right  (type INSTANCE)(allowed-classes TEXT TABLE))
    (     slot footer (type INSTANCE)(allowed-classes      TABLE))
)
(deffunction FORM ($?X) (#TABLE (make-instance of FORM (BORDER 0)) (expand$ ?X)))
(defmethod #TABLE 3100 ((?self FORM))
    (bind ?left   (send ?self get-left  ))
    (bind ?right  (send ?self get-right ))
    (bind ?footer (send ?self get-footer))
    (progn$ (?v ?left) (slot-append$ ?self TRS 
        (TR (TD       ?v ALIGN: RIGHT  COLSPAN: 1)
            (TD (nth$ ?v-index ?right) COLSPAN: 9))
    ))
    (if (neq [nil] ?footer) then
        (slot-append$ ?self TRS (TR (TD ?footer COLSPAN: 10)))
    )
    (return ?self)
)
(defmethod #TABLE 3101 ((?self FORM)(?A TEXT TABLE)(?B TEXT TABLE) $?X) (slot-append$ ?self left  ?A )
                                                                        (slot-append$ ?self right ?B)
                                                                        (#TABLE ?self (expand$ ?X)))
(defmethod #TABLE 3102 ((?self FORM)(?k (eq ?k footer:))(?v TABLE) $?X) (modify-instance ?self (footer ?v))
                                                                        (#TABLE ?self (expand$ ?X)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defclass PROGRESS (is-a TABLE)
    (slot text    (type LEXEME )(default "50%"))
    (slot current (type INTEGER)(default 10))
    (slot total   (type INTEGER)(default 20))
)
(deffunction PROGRESS ($?X) (#TABLE (make-instance of PROGRESS (BORDER 1)(CELLBORDER 0)(CELLSPACING 1)) (expand$ ?X)))
(defmethod #TABLE 4000 ((?self PROGRESS))
    (bind ?TR (TR)) (slot-append$ ?self TRS ?TR)
    (loop-for-count (?i (max 1 (send ?self get-total)))
        (bind ?TD (if (<= ?i (send ?self get-current))
            then (TD (TEXT "") BGCOLOR: gray70 HEIGHT: 4)
            else (TD (TEXT "") BGCOLOR: gray95 HEIGHT: 4)
        ))
        (slot-append$ ?TR TDS ?TD)
    )
    (return ?self)
)
(defmethod #TABLE 4001 ((?self PROGRESS)(?k (eq ?k    text:))(?v LEXEME)      $?X) (modify-instance ?self (text    ?v))
                                                                                   (#TABLE ?self (expand$ ?X)))
(defmethod #TABLE 4002 ((?self PROGRESS)(?k (eq ?k current:))(?v INTEGER)     $?X) (modify-instance ?self (current ?v))
                                                                                   (#TABLE ?self (expand$ ?X)))
(defmethod #TABLE 4003 ((?self PROGRESS)(?k (eq ?k   total:))(?v INTEGER)     $?X) (modify-instance ?self (total   ?v))
                                                                                   (#TABLE ?self (expand$ ?X)))
(defmethod #TABLE 4004 ((?self PROGRESS)(?v LEXEME (not (key-argument-p ?v))) $?X) (#TABLE ?self text: ?v (expand$ ?X)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defclass LABEL (is-a TABLE)
    (slot text (type LEXEME )(default "LABEL"))
)
(deffunction LABEL ($?X) (#TABLE (make-instance of LABEL (BORDER 1)(CELLBORDER 0)) (expand$ ?X)))
(defmethod #TABLE 5000 ((?self LABEL))
    (slot-append$ ?self TRS (TR (TD (TEXT (send ?self get-text)) ALIGN: LEFT)))
    (return ?self)
)
(defmethod #TABLE 5001 ((?self LABEL)(?k (eq ?k    text:))(?v LEXEME)      $?X) (modify-instance ?self (text ?v))
                                                                                (#TABLE ?self (expand$ ?X)))
(defmethod #TABLE 5002 ((?self LABEL)(?v LEXEME (not (key-argument-p ?v))) $?X) (#TABLE ?self text: ?v (expand$ ?X)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defclass TEXTINPUT (is-a TABLE)
    (slot text (type LEXEME )(default "请在此输入..."))
)
(deffunction TEXTINPUT ($?X) (#TABLE (make-instance of TEXTINPUT (BORDER 1)(CELLBORDER 0)) (expand$ ?X)))
(defmethod #TABLE 5100 ((?self TEXTINPUT))
    (slot-append$ ?self TRS (TR (TD (TEXT (send ?self get-text) COLOR: gray) ALIGN: LEFT)))
    (return ?self)
)
(defmethod #TABLE 5101 ((?self TEXTINPUT)(?k (eq ?k    text:))(?v LEXEME)      $?X) (modify-instance ?self (text ?v))
                                                                                    (#TABLE ?self (expand$ ?X)))
(defmethod #TABLE 5102 ((?self TEXTINPUT)(?v LEXEME (not (key-argument-p ?v))) $?X) (#TABLE ?self text: ?v (expand$ ?X)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defclass SEARCH (is-a TABLE)
    (slot text (type LEXEME )(default "请在此输入搜索内容..."))
)
(deffunction SEARCH ($?X) (#TABLE (make-instance of SEARCH (BORDER 1)(CELLBORDER 0)) (expand$ ?X)))
(defmethod #TABLE 5200 ((?self SEARCH))
    (slot-append$ ?self TRS (TR (TD (TEXT (send ?self get-text) COLOR: gray) ALIGN: LEFT)))
    (return ?self)
)
(defmethod #TABLE 5201 ((?self SEARCH)(?k (eq ?k    text:))(?v LEXEME)      $?X) (modify-instance ?self (text ?v))
                                                                                 (#TABLE ?self (expand$ ?X)))
(defmethod #TABLE 5202 ((?self SEARCH)(?v LEXEME (not (key-argument-p ?v))) $?X) (#TABLE ?self text: ?v (expand$ ?X)))

