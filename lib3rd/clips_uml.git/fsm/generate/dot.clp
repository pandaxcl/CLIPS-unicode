;;; vim:expandtab autoindent
;;; map <buffer> \\ :update<CR>:1tabnext<CR>:2wincmd w<CR>:silent normal \\<CR>:7tabnext<CR>
(defglobal ?*准备输出* = +900)
;(defglobal ?*输出节点* = +800)
(defglobal ?*生成代码* = -800)
(defglobal ?*结束输出* = -900)
(defglobal ?*UML* = UML.FSM.DOT)
(defglobal ?*PREFIX* = "Test")

(defmessage-handler Intermediate#Machine 备注点 ()
    (str-cat ?self:名称 . 备注点)
)
(defmessage-handler Intermediate#Machine aspectsWith ()
    (find-all-instances ((?aspect Intermediate#Aspect)) (eq (instance-name ?self) (send ?aspect get-状态机)))
)
(defmessage-handler Intermediate#Machine aspectsOf ()
    (find-all-instances ((?aspect Intermediate#Aspect)) (eq (instance-name ?self) (send ?aspect get-切面)))
)
(defmessage-handler Intermediate#Machine dotForMachine ()
    (bind ?dot (create$))

    (progn ;;; 状态机的table
        (bind ?table (send ?self tableForMachine))
        (bind ?dot (append$ ?dot (str-cat (indent 0) (Q ?self:名称)(S) 
            [label=<<FONT(S)POINT-SIZE=(Q 8)>(join$ (send ?table graphviz))</FONT>>])))
    )
    
    (progn ;;; 状态机的cluster
        (bind ?备注点 (send ?self 备注点))
        (bind ?dot (append-cat$ ?dot (indent 0) subgraph(S)cluster_(I ?self:名称)(S){                           ))
        (bind ?dot (append-cat$ ?dot (indent 1)     label     =(Q ?self:名称)                                   ))
        (bind ?dot (append-cat$ ?dot (indent 1)     labelloc  =(Q t)                                            ))
        (bind ?dot (append-cat$ ?dot (indent 1)     labeljust =(Q l)                                            ))
        (bind ?dot (append-cat$ ?dot (indent 1)     (Q ?备注点)(S)[(S)shape=point,style=invis(S)]               ))
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        (bind ?dot (append-cat$ ?dot (indent 1)     /*(repeat - 25)states(repeat - 25)*/                        ))
        (progn$ (?v (send ?self 状态列表)) 
            (bind ?dot (append$ ?dot                (indent$ 1 (send ?v dotForState)))                          ))
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        (bind ?dot (append-cat$ ?dot (indent 1)     /*(repeat - 14)state-submachine-placeholders(repeat - 13)*/ ))
        (progn$ (?v (send ?self 状态列表)) 
            (bind ?dot (append$ ?dot                (indent$ 1 (send ?v dotForPlaceholders)))                   ))
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        (bind ?dot (append-cat$ ?dot (indent 1)     /*(repeat - 20)transition-nodes(repeat - 20)*/              ))
        (progn$ (?v (send ?self 转换列表))
            (bind ?dot (append$ ?dot                (indent$ 1 (send ?v dotForNode)))                           ))
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        (bind ?dot (append-cat$ ?dot (indent 1)     /*(repeat - 20)transition-edges(repeat - 20)*/              ))
        (progn$ (?v (send ?self 转换列表))
            (bind ?dot (append$ ?dot                (indent$ 1 (send ?v dotForConnection)))                     ))
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        (bind ?dot (append-cat$ ?dot (indent 1)     /*(repeat - 25)aspects(repeat - 24)*/                       ))
        (progn$ (?v (send ?self aspectsWith))
            (bind ?dot (append$ ?dot                (indent$ 1 (send ?v dotForAspect)))                         ))
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        (bind ?dot (append-cat$ ?dot (indent 0) }                                                               ))
    )
    (progn ;;; 连接: table->cluster
        (bind ?备注点 (send ?self 备注点))
        (bind ?style (str-cat dir=both,arrowtail=none,arrowhead=vee,style=dashed,lhead=cluster_(I ?self:名称)))
        (bind ?dot (append-cat$ ?dot (indent 0) (Q ?self:名称)(S)->(S)(Q ?备注点)(S)[(I ?style)]))
    )
    (progn ;;; 连接到 machine's submachines
        (bind ?node (str-cat shape=diamond,style=filled,fontsize=8,margin=0))
        (bind ?edge (str-cat dir=both,arrowtail=diamond,arrowhead=vee,color=gray))
        (progn$ (?v (send ?self 子状态机列表))
            (bind ?v-名称   (send ?v get-名称))
            (bind ?子状态机 (str-cat (I ?self:名称).MachineSubMachine.(I ?v-名称)))
            (bind ?原型     (send (send ?v get-原型) get-名称))
            (bind ?dot (append-cat$ ?dot (indent 0) (Q ?子状态机 )(S)                  [(I ?node),label=(Q ?v-名称)]))
            (bind ?dot (append-cat$ ?dot (indent 0) (Q ?self:名称)(S)->(S)(Q ?子状态机)[(I ?edge)]                  ))
            (bind ?dot (append-cat$ ?dot (indent 0) (Q ?子状态机 )(S)->(S)(Q ?原型    )[(I ?edge)]                  ))
        )
    )
    (progn ;;; 连接到 state's submachines
        (bind ?dot (append-cat$ ?dot (indent 0) /*(repeat - 19)state-submachines(repeat - 19)*/                     ))
        (progn$ (?v (send ?self 状态列表)) 
            (bind ?dot (append$ ?dot            (indent$ 0 (send ?v dotForSubmachines)))                            ))
    )
    (progn ;;; 连接到 machine's aspects
        (bind ?dot (append-cat$ ?dot (indent 0) /*(repeat - 20)machine-aspects(repeat - 20)*/                       ))
        (progn$ (?v (send ?self aspectsWith))
            (bind ?切面名称 (send (send ?v get-切面) get-名称))
            (bind ?切面点   (send ?v 切面点))
            (bind ?中途点   (str-cat ?切面点 -{middle}-> ?切面名称))
            (bind ?edge     (str-cat dir=both,arrowtail=odot,arrowhead=onormal,color=gray,ltail=cluster_(I ?self:名称)))
            (bind ?node     (str-cat shape=circle,color=gray,label=(Q)(Q),width=0.25,height=0.25))
            (bind ?dot (append-cat$ ?dot (indent 0) (Q ?中途点)(S)[(I ?node)]))
            (bind ?dot (append-cat$ ?dot (indent 0) (Q ?切面点)(S)->(S)(Q ?中途点)(S)->(S)(Q ?切面名称)(S)[(I ?edge)]))
        )
    )
    (return ?dot)
)
(deffunction tableForScripts ($?scripts)
    (bind ?table (TABLE))
    (progn$ (?v ?scripts) (slot-append$ ?table 行
        (if (instancep ?v) 
            then (TR (TD (TEXT (send ?v 领域表示)) ALIGN: LEFT))
            else (TR (TD (TEXT       ?v          ) ALIGN: LEFT))
        )
    ))
    (return ?table)
)
(defmessage-handler Intermediate#Machine tableForMachine ()
    (bind ?table (TABLE (TR (TD (TEXT ?self:名称) COLSPAN: 3))))

    (if (neq nil ?self:类) then (slot-append$ ?table 行 (TR
        (TD (TEXT class) COLSPAN: 2)
        (TD (TEXT ?self:类))
    )))
    (if (or (not-empty$ (send ?self aspectsWith))
            (not-empty$ (send ?self aspectsOf  ))) then (slot-append$ ?table 行 (TR
        (TD (TEXT (+ (length$ (send ?self aspectsWith)) (length$ (send ?self aspectsOf)))))
        (TD (TEXT aspects))
        (TD (send ?self tableForAspects))
    )))
    (if (not-empty$ ?self:初始动作) then (slot-append$ ?table 行 (TR
        (TD (TEXT (length$ ?self:初始动作)))
        (TD (TEXT initial))
        (TD (tableForScripts ?self:初始动作))
    )))
    (if (not-empty$ ?self:销毁动作) then (slot-append$ ?table 行 (TR
        (TD (TEXT (length$ ?self:销毁动作)))
        (TD (TEXT terminal))
        (TD (tableForScripts ?self:销毁动作))
    )))
    (if (not-empty$ (send ?self 子状态机列表)) then (slot-append$ ?table 行 (TR
        (TD (TEXT (length$ (send ?self 子状态机列表))))
        (TD (TEXT machines))
        (TD (send ?self tableForSubMachines))
    )))
    (if (not-empty$ (send ?self 变量列表)) then (slot-append$ ?table 行 (TR
        (TD (TEXT (length$ (send ?self 变量列表))))
        (TD (TEXT variables))
        (TD (send ?self tableForVariables))
    )))
    (if (not-empty$ (send ?self 回调列表)) then (slot-append$ ?table 行 (TR
        (TD (TEXT (length$ (send ?self 回调列表))))
        (TD (TEXT callbacks))
        (TD (send ?self tableForCallbacks))
    )))
    (if (not-empty$ (send ?self 状态列表)) then (slot-append$ ?table 行 (TR
        (TD (TEXT (length$ (send ?self 状态列表))))
        (TD (TEXT states))
        (TD (send ?self tableForStates))
    )))
    (if (not-empty$ (send ?self 触发器列表)) then (slot-append$ ?table 行 (TR
        (TD (TEXT (length$ (send ?self 触发器列表))))
        (TD (TEXT triggers))
        (TD (send ?self tableForTriggers))
    )))
    (if (not-empty$ (send ?self 守卫列表)) then (slot-append$ ?table 行 (TR
        (TD (TEXT (length$ (send ?self 守卫列表))))
        (TD (TEXT guards))
        (TD (send ?self tableForGuards))
    )))
    (if (not-empty$ (send ?self 动作列表)) then (slot-append$ ?table 行 (TR
        (TD (TEXT (length$ (send ?self 动作列表))))
        (TD (TEXT actions))
        (TD (send ?self tableForActions))
    )))
    (return ?table)
)
(defmessage-handler Intermediate#Machine tableForVariables ()
    (bind ?table (TABLE))
    (progn$ (?v (send ?self 变量列表))
        (slot-append$ ?table 行 (send ?v rowForVariable))
    )
    (return ?table)
)
(defmessage-handler Intermediate#Machine tableForCallbacks ()
    (bind ?table (TABLE))
    (progn$ (?v (send ?self 回调列表))
        (slot-append$ ?table 行 (send ?v rowForCallback))
    )
    (return ?table)
)
(defmessage-handler Intermediate#Machine tableForSubMachines ()
    (bind ?table (make-instance of TABLE))
    (progn$ (?v (send ?self 子状态机列表))
        (modify-instance ?table (行 (append$ (send ?table get-行) (send ?v rowForSubMachine))))
    )
    (return ?table)
)
(defmessage-handler Intermediate#Machine tableForStates ()
    (bind ?table (make-instance of TABLE))
    (progn$ (?v (send ?self 状态列表)) (modify-instance ?table (行 (append$ (send ?table get-行) (make-instance of TR (列 
        (if (eq ?v ?self:初始状态)
            then (make-instance of TD (内容 (make-instance of TEXT (文本 (send ?v get-名称))))(BGCOLOR gray60))
            else (make-instance of TD (内容 (make-instance of TEXT (文本 (send ?v get-名称)))))
        )
    ))))))
    (return ?table)
)
(defmessage-handler Intermediate#Machine tableForTriggers ()
    (bind ?table (TABLE))
    (progn$ (?v (send ?self 触发器列表))
        (slot-append$ ?table 行 (send ?v rowForTrigger))
    )
    (return ?table)
)
(defmessage-handler Intermediate#Machine tableForGuards ()
    (bind ?table (TABLE))
    (progn$ (?v (send ?self 守卫列表)) 
        (slot-append$ ?table 行 (send ?v rowForGuard))
    )
    (return ?table)
)
(defmessage-handler Intermediate#Machine tableForActions ()
    (bind ?table (TABLE))
    (progn$ (?v (send ?self 动作列表)) 
        (slot-append$ ?table 行 (send ?v rowForAction))
    )
    (return ?table)
)
(defmessage-handler Intermediate#Machine tableForAspects ()
    (bind ?table (TABLE))
    (progn$ (?v (send ?self aspectsWith))
        (slot-append$ ?table 行 (send ?v rowForAspectWith))
    )
    (progn$ (?v (send ?self aspectsOf))
        (slot-append$ ?table 行 (send ?v rowForAspectOf))
    )
    (return ?table)
)

(defmessage-handler Intermediate#Aspect 切面点 ()
    (str-cat (send ?self:状态机 get-名称) . 切面点 -> (send ?self:切面 get-名称))
)
(defmessage-handler Intermediate#Aspect rowForAspectWith ()
    (bind ?名称 (send ?self:切面 get-名称))
    (bind ?TR (TR
        (TD (TEXT 文本:  with)            )
        (TD (TEXT 文本: ?名称) ALIGN: LEFT)
    ))
    (if (empty$ ?self:脚本)
        then (slot-append$ ?TR 列 (TD (TEXT "")))
        else (bind ?table (TABLE))
             (progn$ (?v ?self:脚本) (slot-append$ ?table 行 (TR (TD (TEXT (send ?v 领域表示))))))
             (slot-append$ ?TR 列 (TD ?table))
    )
    (return ?TR)
)
(defmessage-handler Intermediate#Aspect rowForAspectOf ()
    (bind ?名称 (send ?self:状态机 get-名称))
    (bind ?TR (TR
        (TD (TEXT 文本:  of  )            )
        (TD (TEXT 文本: ?名称) ALIGN: LEFT)
    ))
    (if (empty$ ?self:脚本)
        then (slot-append$ ?TR 列 (TD (TEXT "")))
        else (bind ?table (TABLE))
             (progn$ (?v ?self:脚本) (slot-append$ ?table 行 (TR (TD (TEXT (send ?v 领域表示))))))
             (slot-append$ ?TR 列 (TD ?table))
    )
    (return ?TR)
)
(defmessage-handler Intermediate#Aspect dotForAspect ()
    (bind ?dot    (create$))
    (bind ?style  (str-cat shape=point,style=invis))
    (append$ ?dot (str-cat {rank=max(S)(Q (send ?self 切面点))(S)[(I ?style)]}))
)


(defmessage-handler Intermediate#Trigger rowForTrigger ()
    (bind ?TR (TR (TD (TEXT (send ?self:名称 领域表示)) ALIGN: LEFT)))
    (if (not-empty$ ?self:前置脚本) then (slot-append$ ?TR 列 (TD (tableForScripts ?self:前置脚本))))
    (if (not-empty$ ?self:后置脚本) then (slot-append$ ?TR 列 (TD (tableForScripts ?self:后置脚本))))
    (return ?TR)
)
(defmessage-handler Intermediate#Guard rowForGuard ()
    (bind ?TR (TR (TD (TEXT (send ?self:名称 领域表示)) ALIGN: LEFT)))
    (if (not (empty$ ?self:脚本)) then (slot-append$ ?TR 列 (TD (tableForScripts ?self:脚本))))
    (return ?TR)
)
(defmessage-handler Intermediate#Action rowForAction ()
    (bind ?TR (TR (TD (TEXT (send ?self:名称 领域表示)) ALIGN: LEFT)))
    (if (not-empty$ ?self:脚本) then (slot-append$ ?TR 列 (TD (tableForScripts ?self:脚本))))
    (return ?TR)
)

(defmessage-handler Intermediate#State 节点名称 ()
    (str-cat (send ?self:状态机 get-名称) . ?self:名称)
)
(defmessage-handler Intermediate#State tableForTransitions ()
    (bind ?table (make-instance of TABLE))
    (progn$ (?v (send ?self 转换列表))
        (modify-instance ?table (行 (append$ (send ?table get-行) (send ?v rowForTransition))))
    )
    (return ?table)
)
(defmessage-handler Intermediate#State tableForSubMachines ()
    (bind ?table (make-instance of TABLE))
    (progn$ (?v (send ?self 子状态机列表))
        (modify-instance ?table (行 (append$ (send ?table get-行) (send ?v rowForSubMachine))))
    )
    (return ?table)
)
(defmessage-handler Intermediate#State tableForVariables ()
    (bind ?table (TABLE))
    (progn$ (?v (send ?self 变量列表))
        (slot-append$ ?table 行 (send ?v rowForVariable))
    )
    (return ?table)
)
(defmessage-handler Intermediate#State tableForCallbacks ()
    (bind ?table (TABLE))
    (progn$ (?v (send ?self 回调列表))
        (slot-append$ ?table 行 (send ?v rowForCallback))
    )
    (return ?table)
)
(defmessage-handler Intermediate#State tableForState ()
    (bind ?table (TABLE (TR
        (if (eq (instance-name ?self) (send ?self:状态机 get-初始状态))
            then (TD (TEXT ?self:名称) COLSPAN: 2 BGCOLOR: gray60)
            else (TD (TEXT ?self:名称) COLSPAN: 2)
        )
    )))
    (if (neq nil ?self:类) then (slot-append$ ?table 行 (TR
        (TD (TEXT class) COLSPAN: 1)
        (TD (TEXT ?self:类))
    )))
    (if (not-empty$ (send ?self 子状态机列表)) then
        (modify-instance ?table (行 (append$ (send ?table get-行) (make-instance of TR (列 
            (make-instance of TD (内容 (make-instance of TEXT (文本 machines))))
            (make-instance of TD (内容 (send ?self tableForSubMachines)))
        )))))
    )
    (if (not-empty$ (send ?self 变量列表)) then
        (slot-append$ ?table 行 (TR
            (TD (TEXT variables))
            (TD (send ?self tableForVariables))
        ))
    )
    (if (not-empty$ (send ?self 回调列表)) then
        (slot-append$ ?table 行 (TR
            (TD (TEXT callbacks))
            (TD (send ?self tableForCallbacks))
        ))
    )
    (if (not (empty$ ?self:进入动作)) then
        (modify-instance ?table (行 (append$ (send ?table get-行) (make-instance of TR (列 
            (make-instance of TD (内容 (make-instance of TEXT (文本 enter))))
            (make-instance of TD (内容 (tableForScripts ?self:进入动作)))
        )))))
    )
    (if (not (empty$ ?self:离开动作)) then
        (modify-instance ?table (行 (append$ (send ?table get-行) (make-instance of TR (列 
            (make-instance of TD (内容 (make-instance of TEXT (文本 leave))))
            (make-instance of TD (内容 (tableForScripts ?self:离开动作)))
        )))))
    )
    (if (not-empty$ (send ?self 转换列表)) then
        (modify-instance ?table (行 (append$ (send ?table get-行) (make-instance of TR (列 
            (make-instance of TD (内容 (send ?self tableForTransitions))(COLSPAN 2))
        )))))
    )
    (return ?table)
)
(defmessage-handler Intermediate#State dotForState ()
    (bind ?dot   (create$))
    (bind ?node  (send ?self 节点名称))
    (bind ?table (join$ (send (send ?self tableForState) graphviz)))
    (bind ?label (str-cat <<FONT(S)POINT-SIZE=(Q 8)>(I ?table)</FONT>>))
    (bind ?dot   (append$ ?dot (str-cat (Q ?node)(S)[label=(I ?label),style=rounded])))
    (return ?dot)
)
(defmessage-handler Intermediate#State dotForPlaceholders ()
    (bind ?dot  (create$))
    (bind ?node (str-cat shape=doublecircle,style=filled,margin=0,label=(Q ""),width=0.2,height=0.2))
    (bind ?edge (str-cat dir=both,arrowtail=diamond,arrowhead=vee,color=gray,style=dashed))
    (bind ?状态机名称 (send ?self:状态机 get-名称))
    (progn$ (?v (send ?self 子状态机列表))
        (bind ?v-名称   (send ?v    get-名称))
        (bind ?状态节点 (send ?self 节点名称))
        (bind ?占位符   (str-cat (I ?状态机名称).(I ?self:名称).Placeholder.(I ?v-名称)))
        (bind ?dot (append$ ?dot (str-cat (Q ?占位符  )(S)                [(I ?node)])))
        (bind ?dot (append$ ?dot (str-cat (Q ?状态节点)(S)->(S)(Q ?占位符)[(I ?edge)])))
    )
    (return ?dot)
)
(defmessage-handler Intermediate#State dotForSubmachines ()
    (bind ?dot  (create$))
    (bind ?node (str-cat shape=diamond,style=filled,fontsize=8,margin=0))
    (bind ?edge (str-cat dir=both,arrowtail=diamond,arrowhead=vee,color=gray,style=dashed))
    (bind ?状态机名称 (send ?self:状态机 get-名称))
    (progn$ (?v (send ?self 子状态机列表))
        (bind ?v-名称   (send ?v    get-名称))
        (bind ?占位符   (str-cat (I ?状态机名称).(I ?self:名称).Placeholder    .(I ?v-名称)))
        (bind ?子状态机 (str-cat (I ?状态机名称).(I ?self:名称).StateSubMachine.(I ?v-名称)))
        (bind ?原型     (send (send ?v get-原型) get-名称))
        (bind ?dot (append$ ?dot (str-cat (Q ?子状态机)(S)                  [(I ?node),label=(Q ?v-名称)])))
        (bind ?dot (append$ ?dot (str-cat (Q ?占位符  )(S)->(S)(Q ?子状态机)[(I ?edge)])))
        (bind ?dot (append$ ?dot (str-cat (Q ?子状态机)(S)->(S)(Q ?原型    )[(I ?edge)])))
    )
    (return ?dot)
)
(defmessage-handler Intermediate#Transition 转换节点文本 ()
    (str-cat (send ?self:源状态 节点名称) - ?self:触发器 -> (send ?self:目标状态 节点名称))
)
(defmessage-handler Intermediate#Transition rowForTransition ()
    (bind ?guards  (if (not (empty$ ?self:守卫)) 
        then (send ?self tableForGuards )
        else (make-instance of TEXT (文本 ""))
    ))
    (bind ?actions (if (not (empty$ ?self:动作)) 
        then (send ?self tableForActions)
        else (make-instance of TEXT (文本 ""))
    ))
    (TR (TD (TEXT (send ?self:触发器 领域表示)))
        (TD ?guards )
        (TD ?actions)
        (TD (TEXT (send ?self:目标状态 get-名称)))
    )
)
(defmessage-handler Intermediate#Transition tableForGuards ()
    (bind ?table (TABLE))
    (progn$ (?v ?self:守卫) (slot-append$ ?table 行 (TR (TD (TEXT (send ?v 领域表示)) ALIGN: LEFT))))
    (return ?table)
)
(defmessage-handler Intermediate#Transition tableForActions ()
    (bind ?table (TABLE))
    (progn$ (?v ?self:动作) (slot-append$ ?table 行 (TR (TD (TEXT (send ?v 领域表示)) ALIGN: LEFT))))
    (return ?table)
)
(defmessage-handler Intermediate#Transition tableForTransition ()
    (bind ?table (TABLE (TR (TD (TEXT (send ?self:触发器 领域表示)) COLSPAN: 2))))

    (if (not-empty$ ?self:守卫) then
        (slot-append$ ?table 行 (TR 
            (TD (TEXT guards)) 
            (TD (send ?self tableForGuards))
        ))
    )
    (if (not-empty$ ?self:动作) then
        (slot-append$ ?table 行 (TR
            (TD (TEXT actions))
            (TD (send ?self tableForActions))
        ))
    )
    (return ?table)
)
(defmessage-handler Intermediate#Transition dotForNode ()
    (bind ?dot   (create$))
    (bind ?table (join$ (send (send ?self tableForTransition) graphviz)))
    (bind ?style (str-cat label=<<FONT(S)POINT-SIZE=(Q 8)>(I ?table)</FONT>>,shape=none,margin=0,color=gray))
    (bind ?dot   (append$ ?dot (str-cat (Q (send ?self 转换节点文本))(S)[(I ?style)])))
    (return ?dot)
)
(defmessage-handler Intermediate#Transition dotForConnection ()
    (bind ?dot (create$))
    (bind ?源状态   (send ?self:源状态   节点名称))
    (bind ?目标状态 (send ?self:目标状态 节点名称))
    (bind ?节点     (send ?self 转换节点文本))
    (bind ?dot (append$ ?dot (str-cat (Q ?源状态)(S)->(S)(Q ?节点    )(S)[arrowsize=0.5,arrowhead=vee,labelfontsize=8(I)])))
    (bind ?dot (append$ ?dot (str-cat (Q ?节点  )(S)->(S)(Q ?目标状态)(S)[arrowsize=0.5,arrowhead=vee,labelfontsize=8,color=gray(I)])))
    (return ?dot)
)
(defmessage-handler Intermediate#SubMachine rowForSubMachine ()
    (bind ?row (TR (TD (TEXT (send ?self:原型 get-名称)))
                   (TD (TEXT ?self:名称))))
    (if (not-empty$ ?self:脚本) 
        then (bind ?table (TABLE))
             (progn$ (?v ?self:脚本) (slot-append$ ?table 行 (TR (TD (TEXT (send ?v 领域表示)) ALIGN: LEFT))))
             (slot-append$ ?row 列 (TD ?table))
        else (slot-append$ ?row 列 (TD (TEXT "")))
    )
    (return ?row)
)
(defmessage-handler Intermediate#Variable rowForVariable ()
    (bind ?row (TR (TD (TEXT ?self:类型))
                   (TD (TEXT ?self:名称))))

    (if (    empty$ ?self:枚举) then (slot-append$ ?row 列 (TD (TEXT ?self:默认))))
    (if (not-empty$ ?self:枚举) then
        (bind ?table (TABLE))
        (progn$ (?v ?self:枚举)
            (if (eq ?v ?self:默认) 
                then (slot-append$ ?table 行 (TR (TD (TEXT ?v) BGCOLOR: gray)))
                else (slot-append$ ?table 行 (TR (TD (TEXT ?v))))
            )
        )
        (slot-append$ ?row 列 (TD ?table))
    )
    (slot-append$ ?row 列 (TD (TEXT ?self:注解) ALIGN: LEFT))
    (return ?row)
)
(defmessage-handler Intermediate#Callback rowForCallback ()
    (bind ?row (TR (TD (TEXT ?self:名称))))

    (if (not-empty$ ?self:参数)
        then (bind ?table (TABLE))
             (progn$ (?v ?self:参数) (slot-append$ ?table 行 (TR (TD (TEXT ?v)))))
             (slot-append$ ?row 列 (TD ?table))
        else (slot-append$ ?row 列 (TD (TEXT "")))
    )
    (return ?row)
)

(defrule 准备输出
    (declare (salience ?*准备输出*))
=>
    (open (str-cat ?*PREFIX* ".fsm.dot") UML.FSM.DOT "w")
    (printout ?*UML* "strict digraph {" crlf)
    (printout ?*UML* "    node [shape=box]  " crlf)
    (printout ?*UML* "  //splines=ortho     " crlf)
    (printout ?*UML* "  //layout=fdp        " crlf)
    (printout ?*UML* "  //ranksep=2         " crlf)
    (printout ?*UML* "  //nodesep=2         " crlf)
    (printout ?*UML* "    rankdir=LR        " crlf)
    (printout ?*UML* "    compound=true     " crlf)
    (printout ?*UML* "  //concentrate=true  " crlf)
)
(defrule 生成代码
    (declare (salience ?*生成代码*))
    (object (is-a Intermediate#Machine)(name ?dot))
=>
    (printout ?*UML* (indent 1) (join$ (send ?dot dotForMachine) (N)(indent 1)) crlf)
)
(defrule 结束输出
    (declare (salience ?*结束输出*))
=>
    (printout ?*UML* "}" crlf)
)
