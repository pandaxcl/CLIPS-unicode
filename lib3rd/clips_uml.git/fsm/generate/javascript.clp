;;; vim:expandtab autoindent
;;; map <buffer> \\ :update<CR>:1tabnext<CR>:2wincmd w<CR>:silent normal \\<CR>:5tabnext<CR>

(defglobal ?*准备输出* = -910)
(defglobal ?*输出结果* = -920)
(defglobal ?*结束输出* = -930)
(defglobal ?*UML* = UML.FSM.JAVASCRIPT)
(defglobal ?*PREFIX*                    = "Test"
           ?*EVAL-EXPRESSION-ENABLED*   = TRUE
           ?*EVAL-VERBOSE-ENABLED*      = TRUE
           ?*IMPORT-CUSTOM-MODULE-NAME* = (str-cat ?*PREFIX* .custom.js)
)

(defclass JSAction (is-a USER)
    (slot 状态机 (type LEXEME))
    (slot 动作   (type LEXEME))

    (multislot 脚本 (type STRING))
)
(defclass JSTrigger (is-a USER)
    (slot 状态机 (type LEXEME))
    (slot 触发器 (type LEXEME))

    (multislot 前置脚本 (type STRING))
    (multislot 后置脚本 (type STRING))
)
(defclass JSGuard (is-a USER)
    (slot 状态机 (type LEXEME))
    (slot 守卫   (type LEXEME))

    (multislot 脚本 (type STRING))
)
(defclass JSTransition (is-a USER)
    (slot 状态机   (type LEXEME))
    (slot 状态     (type LEXEME))
    (slot 目标状态 (type LEXEME))

    (     slot 触发器 (type LEXEME))
    (multislot 守卫   (type LEXEME))
    (multislot 动作   (type LEXEME))
)
(defclass JSState (is-a USER)
    (slot 状态机 (type LEXEME))
    (slot 状态   (type LEXEME))

    (multislot OnEnter (type STRING))
    (multislot OnLeave (type STRING))

    (multislot SubMachine (type STRING))
    (multislot Variable   (type STRING))

    (multislot Transition (type INSTANCE)(allowed-classes JSTransition))
)
(defclass JSMachine (is-a USER)
    (slot 状态机 (type LEXEME))

    (multislot ConstructorPre   (type STRING))
    (multislot Constructor      (type STRING))
    (multislot Aspect           (type STRING))
    (multislot SubMachine       (type STRING))
    (multislot Variable         (type STRING))
    (multislot ConstructorPost  (type STRING))
    (multislot Prototype        (type STRING))
    (multislot Initialize       (type STRING))
    (multislot Terminate        (type STRING))
    (multislot TransitionBy     (type STRING))
    (multislot InitialActions   (type STRING))
    (multislot TerminalActions  (type STRING))

    (multislot States   (type INSTANCE)(allowed-classes JSState))
    (multislot Triggers (type INSTANCE)(allowed-classes JSTrigger))
    (multislot Actions  (type INSTANCE)(allowed-classes JSAction))
    (multislot Guards   (type INSTANCE)(allowed-classes JSGuard))
)

(deffunction 智能求值 (?value)
    (if ?*EVAL-VERBOSE-ENABLED*
        then (printout t "智能求值：" ?value crlf)
    )
    (if ?*EVAL-EXPRESSION-ENABLED* then 
        (bind ?expression (eval ?value))
        (if (eq FALSE ?expression) then (println [ERROR](S)智能求值出错：(I ?value)))
        (return (send ?expression expression))
    )
    (return ?value)
)

(deffunction 默认值 (?默认 ?类型)
    (bind ?defaultValue (str-cat "(default "?类型" "?默认")"))
    (if (stringp ?默认) 
        then (bind ?defaultValue ?默认)
    )
    (if (eq nil ?默认)
        then (bind ?defaultValue (str-cat "(default "?类型")"))
    )
    (return (智能求值 ?defaultValue))
)
(defmethod transform-from-xxx-to-yyy ((?v LEXEME) (?xxx LEXEME) (?yyy LEXEME))
    (bind ?stmt (explode$ ?v))
    (if (and (str-equal "("  (nth$ 1 ?stmt))
             (str-equal ?xxx (nth$ 2 ?stmt)))
        then (bind ?stmt (replace$ ?stmt 2 2 ?yyy))
    )
    (return (implode$ ?stmt))
)
(deffunction 触发器调用 (?trigger)
    (bind ?stmt (transform-from-xxx-to-yyy ?trigger trigger invoke-trigger))
    (return (智能求值 ?stmt))
)
(deffunction 触发器判断 (?trigger)
    (bind ?stmt (transform-from-xxx-to-yyy ?trigger trigger detect-trigger))
    (return (智能求值 ?stmt))
)
(deffunction 触发器定义 (?trigger)
    (bind ?stmt (transform-from-xxx-to-yyy ?trigger trigger define-trigger))
    (return (智能求值 ?stmt))
)
(deffunction 守卫定义 (?guard)
    (bind ?stmt (transform-from-xxx-to-yyy ?guard guard define-guard))
    (return (智能求值 ?stmt))
)
(deffunction 动作定义 (?action)
    (bind ?stmt (transform-from-xxx-to-yyy ?action action define-action))
    (return (智能求值 ?stmt))
)
(deffunction 动作调用列表 (?actions)
    (bind ?text (create$))
    (progn$ (?v ?actions)
       ;(println "?v = " ?v)
        (bind ?stmt (transform-from-xxx-to-yyy ?v action invoke-action))
        (bind ?text (append$ ?text (智能求值 ?stmt)))
    )
    (return ?text)
)
(deffunction 守卫调用列表 (?guards)
    (bind ?text (create$ "true"))
    (progn$ (?v ?guards)
        (bind ?stmt (transform-from-xxx-to-yyy ?v guard invoke-guard))
        (bind ?text (append$ ?text (智能求值 ?stmt)))
    )
    (return ?text)
)
(deffunction 脚本列表 (?scripts)
    (bind ?text (create$))
    (progn$ (?v ?scripts)
        (bind ?stmt (transform-from-xxx-to-yyy ?v    action  invoke-action ))
        (bind ?stmt (transform-from-xxx-to-yyy ?stmt trigger invoke-trigger))
        (bind ?text (append$ ?text (智能求值 ?stmt)))
    )
    (return ?text)
)
(defmessage-handler JSState output ()
   ;(send ?self print)
    (printout ?*UML* (indent 1) "/* State " ?self:状态 " */" crlf)
    (printout ?*UML* (indent 1) if "(" undefined === this.state[' ?self:状态 '] ")" { crlf)
    (printout ?*UML* (indent 2)     this.state[' ?self:状态 '] = { crlf)
    (printout ?*UML* (indent 3)         submachine  :{}, crlf)
    (printout ?*UML* (indent 3)         variable    :{}, crlf)
    (printout ?*UML* (indent 3)         onEnter     :[], crlf)
    (printout ?*UML* (indent 3)         onLeave     :[], crlf)
    (printout ?*UML* (indent 3)         doTransition:[], crlf)
    (printout ?*UML* (indent 2)     } crlf)
    (printout ?*UML* (indent 2)     this.state[' ?self:状态 '].prototype= "new Custom.State('"?self:状态"', '"?self:状态机"')" crlf)
    (printout ?*UML* (indent 1) } crlf)

    (printout ?*UML* (indent 1) "/* State " ?self:状态 " OnEnter */" crlf)
    (if (not (empty$ ?self:OnEnter)) then
        (printout ?*UML* (indent 1) this.state[' ?self:状态 '].onEnter.push "(" function"()" { crlf)
        (printout ?*UML* (indent 2)     (join$ ?self:OnEnter (str-cat (N) (indent 2))) crlf)
        (printout ?*UML* (indent 1) } ")" crlf)
    )
    (printout ?*UML* (indent 1) "/* State " ?self:状态 " OnLeave */" crlf)
    (if (not (empty$ ?self:OnLeave)) then
        (printout ?*UML* (indent 1) this.state[' ?self:状态 '].onLeave.push "(" function"()" { crlf)
        (printout ?*UML* (indent 2)     (join$ ?self:OnLeave (str-cat (N) (indent 2))) crlf)
        (printout ?*UML* (indent 1) } ")" crlf)
    )
    (printout ?*UML* (indent 1) "/* State " ?self:状态 " Transition */" crlf)
    (if (not (empty$ ?self:Transition)) then
        (printout ?*UML* (indent 1) this.state[' ?self:状态 '].doTransition.push "(" function"(trigger)" { crlf)
                                        (progn$ (?v ?self:Transition) (send ?v output))
        (printout ?*UML* (indent 1) } ")" crlf)
    )

    (printout ?*UML* (indent 1) "/* State " ?self:状态 " SubMachine */" crlf)
    (printout ?*UML* (indent 1) (join$ ?self:SubMachine (str-cat (N) (indent 1))) crlf)
    (printout ?*UML* (indent 1) "/* State " ?self:状态 " Variable */" crlf)
    (printout ?*UML* (indent 1) (join$ ?self:Variable   (str-cat (N) (indent 1))) crlf)
)

(defmessage-handler JSGuard output ()
   ;(send ?self print)
    (printout ?*UML* (indent 0) ?self:状态机 .prototype.guard[' ?self:守卫 ']=function "()" { crlf)
    (printout ?*UML* (indent 1)     "return " (join$ ?self:脚本 (str-cat (N) (indent 1)))    crlf)
    (printout ?*UML* (indent 0) } crlf)
)

(defmessage-handler JSAction output ()
   ;(send ?self print)
    (printout ?*UML* (indent 0) ?self:状态机 .prototype.action[' ?self:动作 ']=function "()" { crlf)
    (printout ?*UML* (indent 1)     (join$ ?self:脚本 (str-cat (N) (indent 1))) crlf)
    (printout ?*UML* (indent 0) } crlf)
)

(defmessage-handler JSTrigger output ()
   ;(send ?self print)
    (printout ?*UML* (indent 0) ?self:状态机 .prototype.trigger[' ?self:触发器 ']=function "()" { crlf)
    (printout ?*UML* (indent 1)     (join$ ?self:前置脚本 (str-cat (N) (indent 1))) crlf)
    (printout ?*UML* (indent 1)     this.transitionByTrigger "(" ' ?self:触发器 ' ")" crlf)
    (printout ?*UML* (indent 1)     (join$ ?self:后置脚本 (str-cat (N) (indent 1))) crlf)
    (printout ?*UML* (indent 0) } crlf)
)

(defmessage-handler JSTransition output ()
   ;(send ?self print)
    (printout ?*UML* (indent 2) if "(" ' ?self:触发器 ' === trigger")" { crlf)
    (printout ?*UML* (indent 3)     if "(" (join$ ?self:守卫 "&&") ")" { crlf)
    (printout ?*UML* (indent 4)         this.state[' ?self:状态 '].onLeave.forEach "(" function "(" onStateLeave ")" { crlf)
    (printout ?*UML* (indent 5)             onStateLeave.call "(this)" crlf)
    (printout ?*UML* (indent 4)         } ")" crlf)
    (printout ?*UML* (indent 4)         (join$ ?self:动作 (str-cat (N) (indent 4))) crlf)
    (printout ?*UML* (indent 4)         this.currentState = ' ?self:目标状态 ' crlf)
    (printout ?*UML* (indent 4)         this.state[' ?self:目标状态 '].onEnter.forEach "(" function "(" onStateEnter ")" { crlf)
    (printout ?*UML* (indent 5)             onStateEnter.call "(this)" crlf)
    (printout ?*UML* (indent 4)         } ")" crlf)
    (printout ?*UML* (indent 3)     } crlf)
    (printout ?*UML* (indent 2) } crlf)
)

(defmessage-handler JSMachine output ()
   ;(send ?self print)
    (printout ?*UML* (indent 0) "export function "?self:状态机"()" { crlf)
    (printout ?*UML* (indent 1)    (join$ ?self:ConstructorPre  (str-cat (N) (indent 1))) crlf)
    (printout ?*UML* (indent 1)    (join$ ?self:Constructor     (str-cat (N) (indent 1))) crlf)
    (printout ?*UML* (indent 1)    (join$ ?self:Aspect          (str-cat (N) (indent 1))) crlf)
    (printout ?*UML* (indent 1)    (join$ ?self:SubMachine      (str-cat (N) (indent 1))) crlf)
    (printout ?*UML* (indent 1)    (join$ ?self:Variable        (str-cat (N) (indent 1))) crlf)
                                   (progn$ (?v ?self:States) (send ?v output))
    (printout ?*UML* (indent 1)    (join$ ?self:ConstructorPost (str-cat (N) (indent 1))) crlf)
    (printout ?*UML* (indent 0) } crlf)

    (printout ?*UML* (indent 0) (join$ ?self:Prototype (str-cat (N) (indent 0))) crlf)

    (printout ?*UML* (indent 0) ?self:状态机 .prototype.initialize = function"()" { crlf)
    (printout ?*UML* (indent 1)     (join$ ?self:InitialActions (str-cat (N) (indent 1))) crlf)
    (printout ?*UML* (indent 1)     (join$ ?self:Initialize (str-cat (N) (indent 1))) crlf)
    (printout ?*UML* (indent 0) } crlf)

    (printout ?*UML* (indent 0) ?self:状态机 .prototype.terminate = function"()" { crlf)
    (printout ?*UML* (indent 1)     (join$ ?self:Terminate (str-cat (N) (indent 1))) crlf)
    (printout ?*UML* (indent 1)     (join$ ?self:TerminalActions (str-cat (N) (indent 1))) crlf)
    (printout ?*UML* (indent 0) } crlf)

    (printout ?*UML* (indent 0) ?self:状态机 .prototype.transitionByTrigger = function"(trigger)" { crlf)
    (printout ?*UML* (indent 1)     (join$ ?self:TransitionBy (str-cat (N) (indent 1))) crlf)
    (printout ?*UML* (indent 0) } crlf)

    (progn$ (?v ?self:Guards)   (send ?v output))
    (progn$ (?v ?self:Actions)  (send ?v output))
    (progn$ (?v ?self:Triggers) (send ?v output))
)


(defrule 准备输出
    (declare (salience ?*准备输出*))
=>
    (open (str-cat ?*PREFIX* ".fsm.js") UML.FSM.JAVASCRIPT "w")
    (printout ?*UML* (indent 0) "import * as Custom from " ' ?*IMPORT-CUSTOM-MODULE-NAME* ' crlf)
)
(defrule 输出结果
    (declare (salience ?*输出结果*))
    (object (is-a JSMachine)(name ?js))
=>
    (send ?js output)
)
(defrule 结束输出
    (declare (salience ?*结束输出*))
=>
    (close UML.FSM.JAVASCRIPT)
)

(defrule 整理状态机数据-Constructor-Make
    (object (is-a Machine) (状态机 ?状态机))
=>
    (make-instance of JSMachine
        (状态机 ?状态机)
        (ConstructorPre  "/* ConstructorPre */")
        (Aspect          "/* Aspect */")
        (SubMachine      "/* SubMachine */")
        (Variable        "/* Variable */")
        (ConstructorPost "/* ConstructorPost */"
                         (str-cat this.currentState          = this.initialState)
                         (str-cat this.prototype.constructor = ?状态机          ))
        (InitialActions  "/* InitialActions */")
        (TerminalActions "/* TerminalActions */")
    )
)
(defrule 整理状态机数据-Constructor-切面
    (object (is-a    Aspect) (状态机 ?状态机) (切面 ?切面))
    (object (is-a JSMachine) (状态机 ?状态机) (name ?js))
=>
    (modify-instance ?js
        (Aspect (append$ (send ?js get-Aspect)
                         (str-cat ?切面 .call"(this)" "/* Aspect of "?状态机" */")))
    )
)
(defrule 整理状态机数据-Constructor-MachineSubMachine
    (object (is-a SubMachine)(状态机 ?状态机)(状态 nil)(子状态机 ?子状态机)(原型 ?原型))
    (object (is-a  JSMachine)(状态机 ?状态机)(name ?js))
=>
    (modify-instance ?js
        (SubMachine (append$ (send ?js get-SubMachine)
                             (str-cat this.submachine[' ?子状态机 '] = new" "?原型"()" "/* MachineSubMachine */")))
    )
)

(defrule 整理状态机数据-Constructor-VariableForMachine
    (object (is-a  Variable)(状态机 ?状态机)(状态 nil)(变量 ?变量)(类型 ?类型)(默认 ?默认)(注解 ?注解))
    (object (is-a JSMachine)(状态机 ?状态机)(name ?js))
=>
    (modify-instance ?js
        (Variable (append$ (send ?js get-Variable)
                           (str-cat this.variable[' (智能求值 ?变量) '] = (默认值 ?默认 ?类型) "/* VariableForMachine */")))
    )
)
(defrule 整理状态机数据-Constructor-StateSubMachine
    (object (is-a SubMachine)(状态机 ?状态机)(状态 ?状态)(子状态机 ?子状态机)(原型 ?原型))
    (object (is-a    JSState)(状态机 ?状态机)(状态 ?状态)(name ?jsstate))
=>
    (modify-instance ?jsstate
        (SubMachine (append$ (send ?jsstate get-SubMachine)
                             (str-cat this.state[' ?状态 '].submachine[' ?子状态机 ']= new" "?原型"()" "/* StateSubMachine */")))
    )
)
(defrule 整理状态机数据-Constructor-VariableForState
    (object (is-a Variable)(状态机 ?状态机)(状态 ?状态)(变量 ?变量)(类型 ?类型)(默认 ?默认)(注解 ?注解))
    (object (is-a  JSState)(状态机 ?状态机)(状态 ?状态)(name ?jsstate))
=>
    (modify-instance ?jsstate
        (Variable (append$ (send ?jsstate get-Variable)
                           (str-cat this.state[' ?状态 '].variable[' ?变量 ']= (默认值 ?默认 ?类型) "/* VariableForState */")))
    )
)

(defrule 整理状态机数据-状态机数据
    (object (is-a   Machine) (状态机 ?状态机) (初始状态 ?初始状态) (初始动作 $?初始动作) (销毁动作 $?销毁动作))
    (object (is-a JSMachine) (状态机 ?状态机) (name ?js))
=>
    (modify-instance ?js
        (ConstructorPre (append$ (send ?js get-ConstructorPre)
                                 (str-cat (indent 0) if"("undefined === this.submachine ")" { this.submachine = {} })
                                 (str-cat (indent 0) if"("undefined === this.variable   ")" { this.variable   = {} })
                                 (str-cat (indent 0) if"("undefined === this.state      ")" { this.state      = {} })))

        (Prototype (str-cat (indent 0) ?状态机 .prototype="new Custom.Machine('"?状态机"')")
                   (str-cat (indent 0) ?状态机 .prototype.initialState=' ?初始状态 ')
                   (str-cat (indent 0) ?状态机 .prototype.action     = {})
                   (str-cat (indent 0) ?状态机 .prototype.guard      = {})
                   (str-cat (indent 0) ?状态机 .prototype.trigger    = {}))

        (Initialize (str-cat (indent 0) this.state[this.initialState].onEnter.forEach "(function(onStateEnter){")
                    (str-cat (indent 1)      onStateEnter.call "(this)")
                    (str-cat (indent 0) "})")
                    (str-cat (indent 0) this.currentState=this.initialState))

        (Terminate (str-cat (indent 0) this.state[this.currentState].onLeave.forEach "(function(onStateLeave){")
                   (str-cat (indent 1)      onStateLeave.call "(this)")
                   (str-cat (indent 0) "})"))

        (TransitionBy (str-cat (indent 0) this.state[this.currentState].doTransition.forEach "(function(onStateTransition){")
                      (str-cat (indent 1)      onStateTransition.call "(this, trigger)")
                      (str-cat (indent 0) "})"))

        (InitialActions  (append$ (send ?js get-InitialActions)  (动作调用列表 ?初始动作)))
        (TerminalActions (append$ (send ?js get-TerminalActions) (动作调用列表 ?销毁动作)))
    )
)
(defrule 整理状态机数据-状态数据
    (object (is-a State)
            (状态机 ?状态机)
            (状态 ?状态)
            (注解 ?注解)
            (进入动作 $?进入动作)
            (离开动作 $?离开动作))
    (object (is-a JSMachine)(name ?js)(状态机 ?状态机))
=>
    (bind ?jsstate (make-instance of JSState
        (状态机 ?状态机)
        (状态   ?状态)

        (OnEnter (动作调用列表 ?进入动作))
        (OnLeave (动作调用列表 ?离开动作))
    ))
    (modify-instance ?js (States (append$ (send ?js get-States) ?jsstate)))
)
(defrule 整理状态机数据-转换数据
    (object (is-a Transition)
            (状态机 ?状态机)
            (状态 ?状态)
            (触发器 ?触发器)
            (目标状态 ?目标状态)
            (守卫 $?守卫)
            (动作 $?动作))
    (object (is-a JSMachine)(name ?js)(状态机 ?状态机))
    (object (is-a JSState)(name ?jsstate)(状态机 ?状态机)(状态 ?状态))
=>
    (bind ?jstransition (make-instance of JSTransition
        (状态机   ?状态机)
        (状态     ?状态)
        (目标状态 ?目标状态)

        (触发器 (触发器判断   ?触发器))
        (守卫   (守卫调用列表 ?守卫))
        (动作   (动作调用列表 ?动作))
    ))
    (modify-instance ?jsstate (Transition (append$ (send ?jsstate get-Transition) ?jstransition)))
)
(defrule 整理状态机数据-动作数据
    (object (is-a Action)(状态机 ?状态机)(动作 ?动作)(注解 ?注解)(脚本 $?脚本))
    (object (is-a JSMachine)(name ?js)(状态机 ?状态机))
=>
    (bind ?jsaction (make-instance of JSAction
        (状态机 ?状态机)
        (动作 (动作定义 ?动作))
        (脚本 (脚本列表 ?脚本))
    ))
    (modify-instance ?js (Actions (append$ (send ?js get-Actions) ?jsaction)))
)
(defrule 整理状态机数据-守卫数据
    (object (is-a Guard)(状态机 ?状态机)(守卫 ?守卫)(注解 ?注解)(脚本 $?脚本))
    (object (is-a JSMachine)(name ?js)(状态机 ?状态机))
=>
    (bind ?jsguard (make-instance of JSGuard
        (状态机 ?状态机)
        (守卫 (守卫定义 ?守卫))
        (脚本 (脚本列表 ?脚本))
    ))
    (modify-instance ?js (Guards (append$ (send ?js get-Guards) ?jsguard)))
)
(defrule 整理状态机数据-触发数据
    (object (is-a Trigger)(状态机 ?状态机)(触发器 ?触发器)(注解 ?注解)
                          (前置脚本 $?前置脚本)
                          (后置脚本 $?后置脚本))
    (object (is-a JSMachine)(name ?js)(状态机 ?状态机))
=>
    (bind ?jstrigger (make-instance of JSTrigger
        (状态机 ?状态机)
        (触发器 (触发器定义 ?触发器))
        (前置脚本 "/* Trigger Pre  Script */" (脚本列表 ?前置脚本))
        (后置脚本 "/* Trigger Post Script */" (脚本列表 ?后置脚本))
    ))
    (modify-instance ?js (Triggers (append$ (send ?js get-Triggers) ?jstrigger)))
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; expression.clp definitions
(defmessage-handler Expression#FSM#Define expression ()
    (bind ?member    (send ?self:member    expression))
    (bind ?arguments (send ?self:arguments expression))
    (bind ?kind (switch ?self:kind
        (case Trigger then trigger  )
        (case Guard   then guard    )
        (case Action  then action   )
        (default (call-next-handler))
    ))
    (str-cat ?member(L)(I ?arguments)(R))
)
(defmessage-handler Expression#FSM#Invoke expression ()
    (bind ?keypath   (send ?self:keypath   expression))
    (bind ?member    (send ?self:member    expression))
    (bind ?arguments (send ?self:arguments expression))
    (bind ?arguments (join$ (explode$ (str-cat ?keypath(S)?arguments)) ", "))
    (bind ?kind (switch ?self:kind
        (case Trigger then trigger  )
        (case Guard   then guard    )
        (case Action  then action   )
        (default (call-next-handler))
    ))
    (str-cat (I ?keypath).(I ?kind)[' ?member '].call(L)(I ?arguments)(R))
)
(defmessage-handler Expression#FSM#Detect expression ()
    (bind ?member    (send ?self:member    expression))
    (bind ?arguments (send ?self:arguments expression))
    (switch ?self:kind
        (case Trigger then (str-cat ?member(L)?arguments(R)))
        (default (call-next-handler))
    )
)
(defmessage-handler Expression#FSM#State expression ()
    (str-cat ' ?self:state ')
)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmessage-handler Expression#Default expression ()
    (switch ?self:type
        (case BOOL    then false)
        (case INTEGER then 0    )
        (case FLOAT   then 0.0  )
        (case SYMBOL  then ""   )
        (case STRING  then ""   )
        (default           null )
    )
)
(defmessage-handler Expression#Comment expression ()
    (str-cat /*(S)(send ?self:comment expression)(S)*/)
)
(defmessage-handler Expression#KeyPath expression ()
    (bind ?path ?self:path)
    (if (str-equal     self (nth$ 1 ?path)) then (bind ?path (replace$ ?path 1 1 this)))
    (if (str-not-equal this (nth$ 1 ?path)) then (bind ?path ( create$  this    ?path)))
    (sym-cat (join$ (explode$ (send ?path expression)) "."))
)
(defmessage-handler Expression#Assign expression ()
    (str-cat (send ?self:left expression) ?self:symbol (send ?self:right expression))
)
(defmessage-handler Expression#Compare expression ()
    (str-cat (send ?self:left expression) ?self:symbol (send ?self:right expression))
)
(defmessage-handler Expression#Logic expression ()
    (bind ?symbol (switch ?self:symbol
        (case not then (str-cat                              "!" (send ?self:right expression)))
        (case and then (str-cat (send ?self:left expression) "&&" (send ?self:right expression)))
        (case or  then (str-cat (send ?self:left expression) "||" (send ?self:right expression)))
        (default (call-next-handler))
    ))
)
