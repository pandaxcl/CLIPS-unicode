;;; vim:expandtab autoindent

(defglobal ?*EXPRESSION-HALT-ENABLED* = TRUE)

;(defgeneric +)
;(defgeneric -)
;(defgeneric *)
;(defgeneric /)
;(defgeneric %)
;(defgeneric eq)
;(defgeneric neq)
;(defgeneric not)
;(defgeneric <)
;(defgeneric <=)
;(defgeneric >)
;(defgeneric >=)

(defgeneric keypath)
(defgeneric  assign)
(defgeneric comment)
(defgeneric default)
(defgeneric parameter)
(defgeneric callback)
(defgeneric lambda)
(defgeneric variable)

(defgeneric #ExpressionParse)
(defmethod  #ExpressionParse ((?self USER)    ) (halt-method-with-arguments #ExpressionParse ?self))
(defmethod  #ExpressionParse ((?self USER) $?X) (halt-method-with-arguments #ExpressionParse ?self (expand$ ?X)))

(deffunction #AtLeastOne (?Expression $?X) (progn$ (?x ?X) (if (subclassp (class ?x) ?Expression) then (return TRUE))) (return FALSE))

(defclass Expression (is-a USER))

(defclass Expression#Default    (is-a Expression) (     slot type     )(slot value))
(defclass Expression#Constant   (is-a Expression) (     slot value    ))
(defclass Expression#Variable   (is-a Expression) (     slot named    ))
(defclass Expression#KeyPath    (is-a Expression) (multislot path     ))
(defclass Expression#Comment    (is-a Expression) (multislot comment  ))
(defclass Expression#Assign     (is-a Expression) (     slot symbol   )(slot left)(slot right))
(defclass Expression#Parameter  (is-a Expression) (     slot type     )(slot parameter)(slot default))
(defclass Expression#Callback   (is-a Expression) (     slot callback )(multislot arguments))
(defclass Expression#Lambda     (is-a Expression) (multislot arguments)(multislot body))
(defclass Expression#Invoke     (is-a Expression) (multislot arguments)(slot function))

(defclass Expression#Numeric (is-a Expression)
    (slot symbol (type LEXEME))
    (slot left   (type INSTANCE NUMBER LEXEME)(allowed-classes Expression))
    (slot right  (type INSTANCE NUMBER LEXEME)(allowed-classes Expression))
)
(defclass Expression#Logic (is-a Expression)
    (slot symbol (type LEXEME))
    (slot left    (type INSTANCE)(allowed-classes Expression))
    (slot right    (type INSTANCE)(allowed-classes Expression))
)
(defclass Expression#Compare (is-a Expression)
    (slot symbol (type LEXEME))
    (slot left    (type INSTANCE)(allowed-classes Expression))
    (slot right    (type INSTANCE)(allowed-classes Expression))
)

;;; 默认实现的消息处理器
(defmessage-handler PRIMITIVE  expression () (return ?self))
(defmessage-handler MULTIFIELD expression () 
    (bind ?result (create$))
    (progn$ (?v ?self)
        (bind ?result (append$ ?result (send ?v expression)))
    )
    (return (implode$ ?result))
)
(defmessage-handler Expression expression ()
    (println [ WARNING ](S)未实现的[(class ?self)](S)message(S)handler:(S)(Q expression))
    (if ?*EXPRESSION-HALT-ENABLED* then (halt))
)

;;; 表达式函数
(defmethod default (?type       ) (make-instance of Expression#Default (type ?type)              ))
(defmethod default (?type ?value) (make-instance of Expression#Default (type ?type)(value ?value)))

(defmethod keypath ($?path   ) (make-instance of Expression#KeyPath (path    ?path   )))
(defmethod comment ($?comment) (make-instance of Expression#Comment (comment ?comment)))

(defmethod parameter (?name (?x (eq : ?x)) ?type (?y (eq = ?y)) ?default) (make-instance of Expression#Parameter (type ?type)(parameter ?name)(default ?default)))
(defmethod parameter (?name (?x (eq : ?x)) ?type                        ) (make-instance of Expression#Parameter (type ?type)(parameter ?name)))
(defmethod parameter (?name                      (?y (eq = ?y)) ?default) (make-instance of Expression#Parameter             (parameter ?name)(default ?default)))
(defmethod parameter (?name                                             ) (make-instance of Expression#Parameter             (parameter ?name)))

(defmethod variable ((?name LEXEME)) (make-instance of Expression#Variable (named ?name)))

(defmethod callback ((?name LEXEME) $?arguments) (make-instance of Expression#Callback (callback ?name)(arguments ?arguments)))
(defmethod invoke   ((?name LEXEME) $?arguments) (make-instance of Expression#Invoke   (function ?name)(arguments ?arguments)))

(defmethod lambda ($?X) (#ExpressionParse (make-instance of Expression#Lambda) (expand$ ?X)))

(defmethod +      (?left (?right (#AtLeastOne Expression ?left ?right))) (make-instance of Expression#Numeric (symbol  + )(left ?left)(right ?right)))
(defmethod -      (?left (?right (#AtLeastOne Expression ?left ?right))) (make-instance of Expression#Numeric (symbol  - )(left ?left)(right ?right)))
(defmethod *      (?left (?right (#AtLeastOne Expression ?left ?right))) (make-instance of Expression#Numeric (symbol  * )(left ?left)(right ?right)))
(defmethod /      (?left (?right (#AtLeastOne Expression ?left ?right))) (make-instance of Expression#Numeric (symbol  / )(left ?left)(right ?right)))
(defmethod %      (?left (?right (#AtLeastOne Expression ?left ?right))) (make-instance of Expression#Numeric (symbol  % )(left ?left)(right ?right)))
(defmethod +=     (?left (?right (#AtLeastOne Expression ?left ?right))) (make-instance of Expression#Assign  (symbol  +=)(left ?left)(right ?right)))
(defmethod -=     (?left (?right (#AtLeastOne Expression ?left ?right))) (make-instance of Expression#Assign  (symbol  -=)(left ?left)(right ?right)))
(defmethod *=     (?left (?right (#AtLeastOne Expression ?left ?right))) (make-instance of Expression#Assign  (symbol  *=)(left ?left)(right ?right)))
(defmethod /=     (?left (?right (#AtLeastOne Expression ?left ?right))) (make-instance of Expression#Assign  (symbol  /=)(left ?left)(right ?right)))
(defmethod %=     (?left (?right (#AtLeastOne Expression ?left ?right))) (make-instance of Expression#Assign  (symbol  %=)(left ?left)(right ?right)))
(defmethod assign (?left (?right (#AtLeastOne Expression ?left ?right))) (make-instance of Expression#Assign  (symbol   =)(left ?left)(right ?right)))
(defmethod ==     (?left (?right (#AtLeastOne Expression ?left ?right))) (make-instance of Expression#Compare (symbol  ==)(left ?left)(right ?right)))
(defmethod !=     (?left (?right (#AtLeastOne Expression ?left ?right))) (make-instance of Expression#Compare (symbol  !=)(left ?left)(right ?right)))
(defmethod >      (?left (?right (#AtLeastOne Expression ?left ?right))) (make-instance of Expression#Compare (symbol  > )(left ?left)(right ?right)))
(defmethod >=     (?left (?right (#AtLeastOne Expression ?left ?right))) (make-instance of Expression#Compare (symbol  >=)(left ?left)(right ?right)))
(defmethod <      (?left (?right (#AtLeastOne Expression ?left ?right))) (make-instance of Expression#Compare (symbol  < )(left ?left)(right ?right)))
(defmethod <=     (?left (?right (#AtLeastOne Expression ?left ?right))) (make-instance of Expression#Compare (symbol  <=)(left ?left)(right ?right)))
(defmethod is     (?left (?right (#AtLeastOne Expression ?left ?right))) (make-instance of Expression#Compare (symbol  is)(left ?left)(right ?right)))
(defmethod not    (?left (?right (#AtLeastOne Expression ?left ?right))) (make-instance of Expression#Logic   (symbol not)(left ?left)(right ?right)))
(defmethod and    (?left (?right (#AtLeastOne Expression ?left ?right))) (make-instance of Expression#Logic   (symbol and)(left ?left)(right ?right)))
(defmethod or     (?left (?right (#AtLeastOne Expression ?left ?right))) (make-instance of Expression#Logic   (symbol  or)(left ?left)(right ?right)))

;;; make-expression
(defmethod make-expression 100 ((?code LEXEME)) (eval ?code))
(defmethod make-expression 101 ((?code MULTIFIELD))
    (bind ?expressions (create$))
    (progn$ (?expr ?expressions)
        (bind ?expressions (append$ ?expressions (make-expression ?expr)))
    )
    (return ?expressions)
)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; lambda
(defmethod #ExpressionParse ((?self Expression#Lambda)) (return ?self))
(defmethod #ExpressionParse ((?self Expression#Lambda)(?argument (neq => ?argument)) $?X) (slot-append$ ?self arguments ?argument) (#ExpressionParse ?self (expand$ ?X)))
(defmethod #ExpressionParse ((?self Expression#Lambda)(?argument ( eq => ?argument)) $?X) (send         ?self put-body  ?X       ) (#ExpressionParse ?self             ))

